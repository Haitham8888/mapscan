[
    {
        "label": "jpype",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "jpype",
        "description": "jpype",
        "detail": "jpype",
        "documentation": {}
    },
    {
        "label": "jaydebeapi",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "jaydebeapi",
        "description": "jaydebeapi",
        "detail": "jaydebeapi",
        "documentation": {}
    },
    {
        "label": "DB2_JARS",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "DB2_JDBC_URL",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "DB2_USERNAME",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "DB2_PASSWORD",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "POPULATION_TABLE",
        "importPath": "config",
        "description": "config",
        "isExtraImport": true,
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "get_db2_connection",
        "importPath": "db.db2",
        "description": "db.db2",
        "isExtraImport": true,
        "detail": "db.db2",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "load_geojson",
        "importPath": "utils.geojson_loader",
        "description": "utils.geojson_loader",
        "isExtraImport": true,
        "detail": "utils.geojson_loader",
        "documentation": {}
    },
    {
        "label": "load_geojson",
        "importPath": "utils.geojson_loader",
        "description": "utils.geojson_loader",
        "isExtraImport": true,
        "detail": "utils.geojson_loader",
        "documentation": {}
    },
    {
        "label": "load_geojson",
        "importPath": "utils.geojson_loader",
        "description": "utils.geojson_loader",
        "isExtraImport": true,
        "detail": "utils.geojson_loader",
        "documentation": {}
    },
    {
        "label": "match_name",
        "importPath": "utils.match",
        "description": "utils.match",
        "isExtraImport": true,
        "detail": "utils.match",
        "documentation": {}
    },
    {
        "label": "match_name",
        "importPath": "utils.match",
        "description": "utils.match",
        "isExtraImport": true,
        "detail": "utils.match",
        "documentation": {}
    },
    {
        "label": "match_name",
        "importPath": "utils.match",
        "description": "utils.match",
        "isExtraImport": true,
        "detail": "utils.match",
        "documentation": {}
    },
    {
        "label": "fetch_population",
        "importPath": "db.queries",
        "description": "db.queries",
        "isExtraImport": true,
        "detail": "db.queries",
        "documentation": {}
    },
    {
        "label": "fetch_population",
        "importPath": "db.queries",
        "description": "db.queries",
        "isExtraImport": true,
        "detail": "db.queries",
        "documentation": {}
    },
    {
        "label": "fetch_population",
        "importPath": "db.queries",
        "description": "db.queries",
        "isExtraImport": true,
        "detail": "db.queries",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "city_bp",
        "importPath": "routes.city",
        "description": "routes.city",
        "isExtraImport": true,
        "detail": "routes.city",
        "documentation": {}
    },
    {
        "label": "district_bp",
        "importPath": "routes.district",
        "description": "routes.district",
        "isExtraImport": true,
        "detail": "routes.district",
        "documentation": {}
    },
    {
        "label": "region_bp",
        "importPath": "routes.region",
        "description": "routes.region",
        "isExtraImport": true,
        "detail": "routes.region",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "urllib.parse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "app",
        "importPath": "app",
        "description": "app",
        "isExtraImport": true,
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "start_jvm",
        "kind": 2,
        "importPath": "db.db2",
        "description": "db.db2",
        "peekOfCode": "def start_jvm():\n    if not jpype.isJVMStarted():\n        # DB2_JARS may be a list of jar paths\n        if isinstance(DB2_JARS, (list, tuple)):\n            classpath = DB2_JARS\n        elif isinstance(DB2_JARS, str):\n            classpath = DB2_JARS.split(os.pathsep)\n        else:\n            classpath = None\n        if classpath:",
        "detail": "db.db2",
        "documentation": {}
    },
    {
        "label": "get_db2_connection",
        "kind": 2,
        "importPath": "db.db2",
        "description": "db.db2",
        "peekOfCode": "def get_db2_connection():\n    start_jvm()\n    # jaydebeapi accepts jars param; pass DB2_JARS as list if available\n    jars = DB2_JARS if isinstance(DB2_JARS, (list, tuple)) else None\n    return jaydebeapi.connect(\n        \"com.ibm.db2.jcc.DB2Driver\",\n        DB2_JDBC_URL,\n        [DB2_USERNAME, DB2_PASSWORD],\n        jars=jars,\n    )",
        "detail": "db.db2",
        "documentation": {}
    },
    {
        "label": "fetch_population",
        "kind": 2,
        "importPath": "db.queries",
        "description": "db.queries",
        "peekOfCode": "def fetch_population(region_id=None, city_id=None, district_id=None):\n    conn = get_db2_connection()\n    cur = conn.cursor()\n    try:\n        if district_id:\n            sql = f\"\"\"SELECT POP_M, POP_F, POP_TOTAL \n                      FROM {POPULATION_TABLE}\n                      WHERE DISTRICT_ID = ?\n                      FETCH FIRST 1 ROWS ONLY\"\"\"\n            params = [district_id]",
        "detail": "db.queries",
        "documentation": {}
    },
    {
        "label": "stats_city",
        "kind": 2,
        "importPath": "routes.city",
        "description": "routes.city",
        "peekOfCode": "def stats_city():\n    city_id = request.args.get(\"city_id\")\n    city_name = request.args.get(\"city_name\")\n    data = load_geojson(\"cities.geojson\")\n    for feat in data.get(\"features\", []):\n        props = feat.get(\"properties\", {}) if isinstance(feat, dict) else feat\n        if city_id and str(props.get(\"city_id\")) == city_id:\n            pop = fetch_population(city_id=city_id)\n            return jsonify({\"city\": props, \"population\": pop, \"feature\": feat})\n        if city_name and match_name(city_name, props):",
        "detail": "routes.city",
        "documentation": {}
    },
    {
        "label": "city_bp",
        "kind": 5,
        "importPath": "routes.city",
        "description": "routes.city",
        "peekOfCode": "city_bp = Blueprint(\"city\", __name__)\n@city_bp.route(\"/stats_city\")\ndef stats_city():\n    city_id = request.args.get(\"city_id\")\n    city_name = request.args.get(\"city_name\")\n    data = load_geojson(\"cities.geojson\")\n    for feat in data.get(\"features\", []):\n        props = feat.get(\"properties\", {}) if isinstance(feat, dict) else feat\n        if city_id and str(props.get(\"city_id\")) == city_id:\n            pop = fetch_population(city_id=city_id)",
        "detail": "routes.city",
        "documentation": {}
    },
    {
        "label": "stats_district",
        "kind": 2,
        "importPath": "routes.district",
        "description": "routes.district",
        "peekOfCode": "def stats_district():\n    district_id = request.args.get(\"district_id\")\n    district_name = request.args.get(\"district_name\")\n    data = load_geojson(\"districts.geojson\")\n    for feat in data.get(\"features\", []):\n        props = feat.get(\"properties\", {}) if isinstance(feat, dict) else feat\n        if district_id and str(props.get(\"district_id\")) == district_id:\n            pop = fetch_population(district_id=district_id)\n            return jsonify({\"district\": props, \"population\": pop, \"feature\": feat})\n        if district_name and match_name(district_name, props):",
        "detail": "routes.district",
        "documentation": {}
    },
    {
        "label": "district_bp",
        "kind": 5,
        "importPath": "routes.district",
        "description": "routes.district",
        "peekOfCode": "district_bp = Blueprint(\"district\", __name__)\n@district_bp.route(\"/stats_district\")\ndef stats_district():\n    district_id = request.args.get(\"district_id\")\n    district_name = request.args.get(\"district_name\")\n    data = load_geojson(\"districts.geojson\")\n    for feat in data.get(\"features\", []):\n        props = feat.get(\"properties\", {}) if isinstance(feat, dict) else feat\n        if district_id and str(props.get(\"district_id\")) == district_id:\n            pop = fetch_population(district_id=district_id)",
        "detail": "routes.district",
        "documentation": {}
    },
    {
        "label": "stats_region",
        "kind": 2,
        "importPath": "routes.region",
        "description": "routes.region",
        "peekOfCode": "def stats_region():\n    region_id = request.args.get(\"region_id\")\n    region_name = request.args.get(\"region_name\")\n    data = load_geojson(\"regions.geojson\")\n    for feat in data.get(\"features\", []):\n        props = feat.get(\"properties\", {}) if isinstance(feat, dict) else feat\n        if region_id and str(props.get(\"region_id\")) == region_id:\n            pop = fetch_population(region_id=region_id)\n            return jsonify({\"region\": props, \"population\": pop, \"feature\": feat})\n        if region_name and match_name(region_name, props):",
        "detail": "routes.region",
        "documentation": {}
    },
    {
        "label": "region_bp",
        "kind": 5,
        "importPath": "routes.region",
        "description": "routes.region",
        "peekOfCode": "region_bp = Blueprint(\"region\", __name__)\n@region_bp.route(\"/stats_region\")\ndef stats_region():\n    region_id = request.args.get(\"region_id\")\n    region_name = request.args.get(\"region_name\")\n    data = load_geojson(\"regions.geojson\")\n    for feat in data.get(\"features\", []):\n        props = feat.get(\"properties\", {}) if isinstance(feat, dict) else feat\n        if region_id and str(props.get(\"region_id\")) == region_id:\n            pop = fetch_population(region_id=region_id)",
        "detail": "routes.region",
        "documentation": {}
    },
    {
        "label": "load_geojson",
        "kind": 2,
        "importPath": "utils.geojson_loader",
        "description": "utils.geojson_loader",
        "peekOfCode": "def load_geojson(file_name):\n    path = os.path.join(BASE_PATH, file_name)\n    if not os.path.isfile(path):\n        return {\"features\": []}\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        try:\n            data = json.load(f)\n        except Exception:\n            return {\"features\": []}\n    if isinstance(data, dict) and \"features\" in data and isinstance(data[\"features\"], list):",
        "detail": "utils.geojson_loader",
        "documentation": {}
    },
    {
        "label": "BASE_PATH",
        "kind": 5,
        "importPath": "utils.geojson_loader",
        "description": "utils.geojson_loader",
        "peekOfCode": "BASE_PATH = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'geojson'))\ndef load_geojson(file_name):\n    path = os.path.join(BASE_PATH, file_name)\n    if not os.path.isfile(path):\n        return {\"features\": []}\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        try:\n            data = json.load(f)\n        except Exception:\n            return {\"features\": []}",
        "detail": "utils.geojson_loader",
        "documentation": {}
    },
    {
        "label": "match_name",
        "kind": 2,
        "importPath": "utils.match",
        "description": "utils.match",
        "peekOfCode": "def match_name(value, props, fields=(\"name\", \"NAME\", \"name_en\", \"name_ar\")):\n    needle = str(value).strip().lower()\n    for f in fields:\n        v = props.get(f)\n        if v and str(v).strip().lower() == needle:\n            return True\n    # Soft match\n    for f in fields:\n        v = props.get(f)\n        if v and str(v).strip().lower().replace(\"-\", \" \") == needle.replace(\"-\", \" \"):",
        "detail": "utils.match",
        "documentation": {}
    },
    {
        "label": "home",
        "kind": 2,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "def home():\n    return {\"status\": \"OK\", \"message\": \"DB2 + Flask API Ready\"}\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=5001, debug=True)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "app",
        "description": "app",
        "peekOfCode": "app = Flask(__name__)\n# register blueprints\napp.register_blueprint(city_bp)\napp.register_blueprint(district_bp)\napp.register_blueprint(region_bp)\n@app.route(\"/\")\ndef home():\n    return {\"status\": \"OK\", \"message\": \"DB2 + Flask API Ready\"}\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=5001, debug=True)",
        "detail": "app",
        "documentation": {}
    },
    {
        "label": "DB2_JDBC_URL",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "DB2_JDBC_URL = \"jdbc:db2://192.168.1.55:50000/BLUDB\"\nDB2_USERNAME = \"db2inst1\"\nDB2_PASSWORD = \"Pass123\"\nDB2_JARS = [\n    \"/opt/ibm/driver/db2jcc4.jar\",\n    \"/opt/ibm/driver/db2jcc4_license_cu.jar\"\n]\nPOPULATION_TABLE = \"EDWH.POPULATION_TABLE\"",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "DB2_USERNAME",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "DB2_USERNAME = \"db2inst1\"\nDB2_PASSWORD = \"Pass123\"\nDB2_JARS = [\n    \"/opt/ibm/driver/db2jcc4.jar\",\n    \"/opt/ibm/driver/db2jcc4_license_cu.jar\"\n]\nPOPULATION_TABLE = \"EDWH.POPULATION_TABLE\"",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "DB2_PASSWORD",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "DB2_PASSWORD = \"Pass123\"\nDB2_JARS = [\n    \"/opt/ibm/driver/db2jcc4.jar\",\n    \"/opt/ibm/driver/db2jcc4_license_cu.jar\"\n]\nPOPULATION_TABLE = \"EDWH.POPULATION_TABLE\"",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "DB2_JARS",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "DB2_JARS = [\n    \"/opt/ibm/driver/db2jcc4.jar\",\n    \"/opt/ibm/driver/db2jcc4_license_cu.jar\"\n]\nPOPULATION_TABLE = \"EDWH.POPULATION_TABLE\"",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "POPULATION_TABLE",
        "kind": 5,
        "importPath": "config",
        "description": "config",
        "peekOfCode": "POPULATION_TABLE = \"EDWH.POPULATION_TABLE\"",
        "detail": "config",
        "documentation": {}
    },
    {
        "label": "load_sample_data",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def load_sample_data():\n\t\"\"\"Load and cache sample GeoJSON file from the repository.\"\"\"\n\tglobal _SAMPLE_CACHE\n\tif _SAMPLE_CACHE is not None:\n\t\treturn _SAMPLE_CACHE\n\t# First attempt: if JDBC + SQL specified, try to fetch features from DB\n\tif SAMPLE_GEOJSON_SQL and (_JDBC_AVAILABLE and SAMPLE_GEOJSON_JDBC_URL and SAMPLE_GEOJSON_JDBC_DRIVER):\n\t\ttry:\n\t\t\t# ensure JVM started if needed\n\t\t\tif not jpype.isJVMStarted():",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "query_sample_sum",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def query_sample_sum(neighborhood_field, neighborhood_value, population_field):\n\t\"\"\"Query the local sample GeoJSON and sum population for matching neighborhood name.\"\"\"\n\tdata = load_sample_data()\n\ttotal = 0\n\tcount = 0\n\tneedle = str(neighborhood_value).strip().lower()\n\tfor feat in data.get('features', []):\n\t\tprops = feat.get('properties', {})\n\t\t# try multiple candidate name fields (case-insensitive)\n\t\tcandidates = []",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "query_sample_feature",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def query_sample_feature(neighborhood_field, neighborhood_value):\n\t\"\"\"Return the first matching sample feature plus population breakdown by gender.\"\"\"\n\tdata = load_sample_data()\n\tneedle = str(neighborhood_value).strip().lower()\n\tfor feat in data.get('features', []):\n\t\tprops = feat.get('properties', {})\n\t\tcandidates = []\n\t\tfor k in [neighborhood_field, neighborhood_field.upper(), neighborhood_field.lower(), 'NAME', 'name', 'EN_NAME', 'en_name']:\n\t\t\tv = props.get(k)\n\t\t\tif v:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "query_sample_group_sum",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def query_sample_group_sum(neighborhood_field, population_field):\n\t\"\"\"Return grouped sums from sample geojson keyed by neighborhood_field.\"\"\"\n\tdata = load_sample_data()\n\tgroups = {}\n\tfor feat in data.get('features', []):\n\t\tprops = feat.get('properties', {})\n\t\t# prefer Arabic NAME, fall back to EN_NAME\n\t\tname = props.get(neighborhood_field) or props.get('NAME') or props.get('name') or props.get('EN_NAME')\n\t\tif not name:\n\t\t\tcontinue",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "load_region_populations",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def load_region_populations():\n\tglobal _REGION_POP_CACHE\n\tif _REGION_POP_CACHE is not None:\n\t\treturn _REGION_POP_CACHE\n\tif not os.path.isfile(REGION_POP_PATH):\n\t\t_REGION_POP_CACHE = {}\n\t\treturn _REGION_POP_CACHE\n\twith open(REGION_POP_PATH, 'r', encoding='utf-8') as fh:\n\t\t_REGION_POP_CACHE = json.load(fh)\n\treturn _REGION_POP_CACHE",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "query_population_by_ids",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def query_population_by_ids(region_id=None, city_id=None, district_id=None):\n\t\"\"\"Query population table prioritizing district -> city -> region.\n\tExpected table `population` with columns: region_id, city_id, district_id, pop_m, pop_f, pop_total\n\t\"\"\"\n\tconn = _get_db_connection()\n\tif not conn:\n\t\treturn None\n\tcur = None\n\ttry:\n\t\tcur = conn.cursor()",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "load_external_file",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def load_external_file(key):\n\t\"\"\"Load a GeoJSON/JSON file from ALLOWED_FILES by key and cache it in memory.\"\"\"\n\tpath = ALLOWED_FILES.get(key)\n\tif not path or not os.path.isfile(path):\n\t\treturn {'features': []}\n\twith open(path, 'r', encoding='utf-8') as fh:\n\t\ttry:\n\t\t\traw = json.load(fh)\n\t\texcept Exception:\n\t\t\treturn {'features': []}",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "query_file_feature",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def query_file_feature(file_key, neighborhood_value, name_field_candidates=None):\n\t\"\"\"Generic search in an external GeoJSON/JSON file for a matching neighborhood name.\n\tname_field_candidates: list of candidate property names to try (defaults to common names)\n\t\"\"\"\n\tdata = load_external_file(file_key)\n\tneedle = str(neighborhood_value).strip().lower()\n\tif name_field_candidates is None:\n\t\t# include common English and Arabic name fields and variants\n\t\tname_field_candidates = [\n\t\t\t'name', 'NAME', 'Name',",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "normalize_feature_to_geojson",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def normalize_feature_to_geojson(feat):\n\t\"\"\"Return a GeoJSON Feature dict for various input shapes.\n\tConverts files that use `boundaries` (arrays of [lat,lon]) into a\n\tGeoJSON Polygon geometry with coordinates as [lon, lat].\n\t\"\"\"\n\t# If it's already a GeoJSON Feature\n\tif not isinstance(feat, dict):\n\t\treturn None\n\tif feat.get('type') == 'Feature' and isinstance(feat.get('geometry'), dict):\n\t\treturn feat",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "find_polygon_for_feature",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def find_polygon_for_feature(props):\n\t\"\"\"Search allowed files for a feature that matches `props` by id or name and contains polygon geometry.\n\tReturns a GeoJSON feature or None.\n\t\"\"\"\n\tif not isinstance(props, dict):\n\t\treturn None\n\t# Candidate keys to try for id and names\n\tid_keys = ['city_id', 'region_id', 'district_id', 'id', 'region_id']\n\tname_keys = ['name_en', 'name_ar', 'name', 'NAME', 'EN_NAME']\n\t# Collect values to match",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "stats_city",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def stats_city():\n\t\"\"\"Return a city feature (prefer polygon) by `city_id` or `city_name`.\n\tQuery params:\n\t- city_id (optional): numeric id\n\t- city_name (optional): name string\n\t\"\"\"\n\tcity_id = request.args.get('city_id')\n\tcity_name = request.args.get('city_name')\n\t# Optional region context to disambiguate cities with same name\n\tregion_id = request.args.get('region_id')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "stats_district",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def stats_district():\n\t\"\"\"Return a district feature by `district_id`/`district_name` optionally scoped to a city (`city_id` or `city_name`).\"\"\"\n\tdistrict_id = request.args.get('district_id')\n\tdistrict_name = request.args.get('district_name')\n\tcity_id = request.args.get('city_id')\n\tcity_name = request.args.get('city_name')\n\tif not district_id and not district_name:\n\t\treturn jsonify({'error': 'missing district identifier'}), 400\n\t# prefer district files first\n\tdistrict_keys = [k for k in ALLOWED_FILES.keys() if 'district' in k]",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "stats_region",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def stats_region():\n\t\"\"\"Return a region feature (prefer polygon) by `region_id` or `region_name`.\n\tQuery params:\n\t- region_id (optional)\n\t- region_name (optional)\n\t\"\"\"\n\tregion_id = request.args.get('region_id')\n\tregion_name = request.args.get('region_name')\n\t# Try region-specific files first\n\tregion_keys = [k for k in ALLOWED_FILES.keys() if 'region' in k]",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "city_districts",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def city_districts():\n\t\"\"\"Return a FeatureCollection of district features for a given city.\n\tQuery params:\n\t- city_id (optional)\n\t- city_name (optional)\n\t\"\"\"\n\tcity_id = request.args.get('city_id')\n\tcity_name = request.args.get('city_name')\n\tif not city_id and not city_name:\n\t\treturn jsonify({'error': 'missing city identifier'}), 400",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "query_all_files",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def query_all_files(neighborhood_value, name_field_candidates=None):\n\t\"\"\"Search all allowed files in order and return the first matching feature.\n\tReturns a tuple (key, feature) or (None, None) if not found.\n\t\"\"\"\n\tfor key in ALLOWED_FILES.keys():\n\t\tfeat = query_file_feature(key, neighborhood_value, name_field_candidates)\n\t\tif feat:\n\t\t\treturn key, feat\n\treturn None, None\ndef query_all_matches(query_value, name_field_candidates=None, limit=50):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "query_all_matches",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def query_all_matches(query_value, name_field_candidates=None, limit=50):\n\t\"\"\"Return a list of matching candidate features across all allowed files.\n\tMatching is performed by case-insensitive substring match against common name fields.\n\tReturns list of dicts: {file_key, id, name_en, name_ar, props}\n\t\"\"\"\n\tq = (query_value or '').strip().lower()\n\tif not q:\n\t\treturn []\n\tif name_field_candidates is None:\n\t\tname_field_candidates = [",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "stats_search_all",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def stats_search_all():\n\t\"\"\"Search across all provided geojson/json files for a neighborhood name.\n\tQuery params:\n\t- neighborhood (required)\n\t- name_field (optional) comma-separated candidate property names\n\t\"\"\"\n\tneighborhood = request.args.get('neighborhood')\n\tif not neighborhood:\n\t\treturn jsonify({'error': 'missing neighborhood parameter'}), 400\n\tname_field_param = request.args.get('name_field')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "search_suggest",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def search_suggest():\n\t\"\"\"Return a list of matching name suggestions across allowed files.\n\tQuery params:\n\t- q: query string (required)\n\t- limit: max results (optional)\n\t\"\"\"\n\tq = request.args.get('q')\n\tif not q:\n\t\treturn jsonify({'error': 'missing q parameter'}), 400\n\ttry:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "list_regions",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def list_regions():\n\t# prefer json/regions.json then geojson/regions.geojson\n\tregions = _load_list_from_key('json_regions') if 'json_regions' in ALLOWED_FILES else []\n\tif not regions and 'geo_regions' in ALLOWED_FILES:\n\t\tregions = _load_list_from_key('geo_regions')\n\t# remove duplicates and sort\n\tseen = set()\n\tout = []\n\tfor r in regions:\n\t\tkey = (str(r.get('id')), str(r.get('name_en') or r.get('name_ar') or ''))",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "list_cities",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def list_cities():\n\t# Accept either region_id or region_name\n\tregion_id = request.args.get('region_id')\n\tregion_name = request.args.get('region_name')\n\t# load cities from json_cities or geo_cities\n\tcities = []\n\tif 'json_cities' in ALLOWED_FILES:\n\t\tcities = _load_list_from_key('json_cities', id_field_candidates=('city_id',), name_field_candidates=('name_en','name_ar'))\n\telif 'geo_cities' in ALLOWED_FILES:\n\t\tcities = _load_list_from_key('geo_cities', id_field_candidates=('city_id',), name_field_candidates=('name_en','name_ar'))",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "list_districts",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def list_districts():\n\t# Accept city_id or city_name\n\tcity_id = request.args.get('city_id')\n\tcity_name = request.args.get('city_name')\n\tdistricts = []\n\tif 'json_districts' in ALLOWED_FILES:\n\t\tdistricts = _load_list_from_key('json_districts', id_field_candidates=('district_id','id'), name_field_candidates=('name_en','name_ar'))\n\telif 'geo_districts' in ALLOWED_FILES:\n\t\tdistricts = _load_list_from_key('geo_districts', id_field_candidates=('district_id','id'), name_field_candidates=('name_en','name_ar'))\n\tif city_id:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "stats_file_feature",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def stats_file_feature():\n\t\"\"\"Return a matched feature from one of the allowed external files.\n\tQuery params:\n\t- file: key of ALLOWED_FILES (required)\n\t- neighborhood: name to search (required)\n\t- name_field (optional): comma-separated list of property names to try\n\t\"\"\"\n\tfile_key = request.args.get('file')\n\tneighborhood = request.args.get('neighborhood')\n\tif not file_key or file_key not in ALLOWED_FILES:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "query_layer_sum",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def query_layer_sum(layer_url, neighborhood_field, neighborhood_value, population_field):\n\t\"\"\"Query the ArcGIS FeatureLayer for features matching a neighborhood and sum the population field.\"\"\"\n\t# Build a safe where clause; ArcGIS expects single quotes around string values\n\twhere = f\"{neighborhood_field} = '{neighborhood_value.replace(\"'\",\"''\")}'\"\n\tparams = {\n\t\t'where': where,\n\t\t'outFields': population_field,\n\t\t'returnGeometry': 'false',\n\t\t'f': 'json'\n\t}",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "query_layer_group_sum",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def query_layer_group_sum(layer_url, neighborhood_field, population_field, where_clause='1=1'):\n\t\"\"\"Query the layer to get summed population grouped by neighborhood field.\n\tUses the ArcGIS `outStatistics` + `groupByFieldsForStatistics` parameters.\"\"\"\n\t# outStatistics must be JSON encoded\n\tout_statistics = json.dumps([\n\t\t{\"statisticType\": \"sum\", \"onStatisticField\": population_field, \"outStatisticFieldName\": \"SUM_POP\"}\n\t])\n\tparams = {\n\t\t'where': where_clause,\n\t\t'f': 'json',",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "index",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def index():\n\t# Render a simple page that loads ESRI map and calls this API for stats\n\treturn render_template('map.html')\n@app.route('/stats')\ndef stats():\n\t\"\"\"Return population statistics for a single neighborhood.\n\tQuery params:\n\t- neighborhood (required): neighborhood name (string)\n\t- layer_url (optional): override default feature layer URL\n\t- neighborhood_field (optional): field name for neighborhood",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "stats",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def stats():\n\t\"\"\"Return population statistics for a single neighborhood.\n\tQuery params:\n\t- neighborhood (required): neighborhood name (string)\n\t- layer_url (optional): override default feature layer URL\n\t- neighborhood_field (optional): field name for neighborhood\n\t- population_field (optional): field name for population\n\t\"\"\"\n\tneighborhood = request.args.get('neighborhood')\n\tif not neighborhood:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "stats_all",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def stats_all():\n\t\"\"\"Return grouped population sums for all neighborhoods.\n\tQuery params (optional): layer_url, neighborhood_field, population_field\n\t\"\"\"\n\tlayer_url = request.args.get('layer_url', DEFAULT_LAYER_URL)\n\tneighborhood_field = request.args.get('neighborhood_field', DEFAULT_NEIGHBOR_FIELD)\n\tpopulation_field = request.args.get('population_field', DEFAULT_POP_FIELD)\n\twhere_clause = request.args.get('where', '1=1')\n\ttry:\n\t\tstats = query_layer_group_sum(layer_url, neighborhood_field, population_field, where_clause)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "stats_sample",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def stats_sample():\n\t\"\"\"Return population statistics using the local sample GeoJSON file.\n\tQuery params:\n\t- neighborhood (required)\n\t- neighborhood_field (optional) defaults to NAME\n\t- population_field (optional) defaults to POP\n\t\"\"\"\n\tneighborhood = request.args.get('neighborhood')\n\tif not neighborhood:\n\t\treturn jsonify({'error': 'missing neighborhood parameter'}), 400",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "stats_all_sample",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def stats_all_sample():\n\t\"\"\"Return grouped population sums for the sample GeoJSON.\"\"\"\n\tneighborhood_field = request.args.get('neighborhood_field', 'NAME')\n\tpopulation_field = request.args.get('population_field', 'POP')\n\tstats = query_sample_group_sum(neighborhood_field, population_field)\n\treturn jsonify({'stats': stats})\n@app.route('/stats_sample_feature')\ndef stats_sample_feature():\n\t\"\"\"Return a single matching feature with geometry and gender breakdown for the sample GeoJSON.\n\tQuery params:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "stats_sample_feature",
        "kind": 2,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "def stats_sample_feature():\n\t\"\"\"Return a single matching feature with geometry and gender breakdown for the sample GeoJSON.\n\tQuery params:\n\t- neighborhood (required)\n\t- neighborhood_field (optional)\n\t\"\"\"\n\tneighborhood = request.args.get('neighborhood')\n\tif not neighborhood:\n\t\treturn jsonify({'error': 'missing neighborhood parameter'}), 400\n\tneighborhood_field = request.args.get('neighborhood_field', 'NAME')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t_JDBC_AVAILABLE",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t_JDBC_AVAILABLE = True\nexcept Exception:\n\t# jaydebeapi / jpype not installed or JVM not available; we'll fall back to sqlite when necessary\n\t_JDBC_AVAILABLE = False\nimport sqlite3\napp = Flask(__name__)\n# Default configuration - replace with the actual FeatureLayer URL and field names\n# Example layer URL (replace with your Saudi neighborhoods feature layer):\nDEFAULT_LAYER_URL = \"https://sampleserver6.arcgisonline.com/arcgis/rest/services/Census/MapServer/3\"\nDEFAULT_NEIGHBOR_FIELD = \"NAME\"  # field that contains neighborhood name",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t_JDBC_AVAILABLE",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t_JDBC_AVAILABLE = False\nimport sqlite3\napp = Flask(__name__)\n# Default configuration - replace with the actual FeatureLayer URL and field names\n# Example layer URL (replace with your Saudi neighborhoods feature layer):\nDEFAULT_LAYER_URL = \"https://sampleserver6.arcgisonline.com/arcgis/rest/services/Census/MapServer/3\"\nDEFAULT_NEIGHBOR_FIELD = \"NAME\"  # field that contains neighborhood name\nDEFAULT_POP_FIELD = \"POP2000\"   # field that contains population (example)\n# Sample GeoJSON source: prefer DB-driven SQL when configured via env vars, otherwise fallback to local file\n# Environment variables:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "app = Flask(__name__)\n# Default configuration - replace with the actual FeatureLayer URL and field names\n# Example layer URL (replace with your Saudi neighborhoods feature layer):\nDEFAULT_LAYER_URL = \"https://sampleserver6.arcgisonline.com/arcgis/rest/services/Census/MapServer/3\"\nDEFAULT_NEIGHBOR_FIELD = \"NAME\"  # field that contains neighborhood name\nDEFAULT_POP_FIELD = \"POP2000\"   # field that contains population (example)\n# Sample GeoJSON source: prefer DB-driven SQL when configured via env vars, otherwise fallback to local file\n# Environment variables:\n#  SAMPLE_GEOJSON_SQL - SQL query that returns one or more rows where first column is a GeoJSON Feature or FeatureCollection string\n#  SAMPLE_GEOJSON_JDBC_URL, SAMPLE_GEOJSON_JDBC_DRIVER, SAMPLE_GEOJSON_JDBC_JARS, SAMPLE_GEOJSON_JDBC_USER, SAMPLE_GEOJSON_JDBC_PASS",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "DEFAULT_LAYER_URL",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "DEFAULT_LAYER_URL = \"https://sampleserver6.arcgisonline.com/arcgis/rest/services/Census/MapServer/3\"\nDEFAULT_NEIGHBOR_FIELD = \"NAME\"  # field that contains neighborhood name\nDEFAULT_POP_FIELD = \"POP2000\"   # field that contains population (example)\n# Sample GeoJSON source: prefer DB-driven SQL when configured via env vars, otherwise fallback to local file\n# Environment variables:\n#  SAMPLE_GEOJSON_SQL - SQL query that returns one or more rows where first column is a GeoJSON Feature or FeatureCollection string\n#  SAMPLE_GEOJSON_JDBC_URL, SAMPLE_GEOJSON_JDBC_DRIVER, SAMPLE_GEOJSON_JDBC_JARS, SAMPLE_GEOJSON_JDBC_USER, SAMPLE_GEOJSON_JDBC_PASS\nSAMPLE_GEOJSON_SQL = os.environ.get('SAMPLE_GEOJSON_SQL')\nSAMPLE_GEOJSON_JDBC_URL = os.environ.get('SAMPLE_GEOJSON_JDBC_URL')\nSAMPLE_GEOJSON_JDBC_DRIVER = os.environ.get('SAMPLE_GEOJSON_JDBC_DRIVER')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "DEFAULT_NEIGHBOR_FIELD",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "DEFAULT_NEIGHBOR_FIELD = \"NAME\"  # field that contains neighborhood name\nDEFAULT_POP_FIELD = \"POP2000\"   # field that contains population (example)\n# Sample GeoJSON source: prefer DB-driven SQL when configured via env vars, otherwise fallback to local file\n# Environment variables:\n#  SAMPLE_GEOJSON_SQL - SQL query that returns one or more rows where first column is a GeoJSON Feature or FeatureCollection string\n#  SAMPLE_GEOJSON_JDBC_URL, SAMPLE_GEOJSON_JDBC_DRIVER, SAMPLE_GEOJSON_JDBC_JARS, SAMPLE_GEOJSON_JDBC_USER, SAMPLE_GEOJSON_JDBC_PASS\nSAMPLE_GEOJSON_SQL = os.environ.get('SAMPLE_GEOJSON_SQL')\nSAMPLE_GEOJSON_JDBC_URL = os.environ.get('SAMPLE_GEOJSON_JDBC_URL')\nSAMPLE_GEOJSON_JDBC_DRIVER = os.environ.get('SAMPLE_GEOJSON_JDBC_DRIVER')\nSAMPLE_GEOJSON_JDBC_JARS = os.environ.get('SAMPLE_GEOJSON_JDBC_JARS')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "DEFAULT_POP_FIELD",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "DEFAULT_POP_FIELD = \"POP2000\"   # field that contains population (example)\n# Sample GeoJSON source: prefer DB-driven SQL when configured via env vars, otherwise fallback to local file\n# Environment variables:\n#  SAMPLE_GEOJSON_SQL - SQL query that returns one or more rows where first column is a GeoJSON Feature or FeatureCollection string\n#  SAMPLE_GEOJSON_JDBC_URL, SAMPLE_GEOJSON_JDBC_DRIVER, SAMPLE_GEOJSON_JDBC_JARS, SAMPLE_GEOJSON_JDBC_USER, SAMPLE_GEOJSON_JDBC_PASS\nSAMPLE_GEOJSON_SQL = os.environ.get('SAMPLE_GEOJSON_SQL')\nSAMPLE_GEOJSON_JDBC_URL = os.environ.get('SAMPLE_GEOJSON_JDBC_URL')\nSAMPLE_GEOJSON_JDBC_DRIVER = os.environ.get('SAMPLE_GEOJSON_JDBC_DRIVER')\nSAMPLE_GEOJSON_JDBC_JARS = os.environ.get('SAMPLE_GEOJSON_JDBC_JARS')\nSAMPLE_GEOJSON_JDBC_USER = os.environ.get('SAMPLE_GEOJSON_JDBC_USER')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "SAMPLE_GEOJSON_SQL",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "SAMPLE_GEOJSON_SQL = os.environ.get('SAMPLE_GEOJSON_SQL')\nSAMPLE_GEOJSON_JDBC_URL = os.environ.get('SAMPLE_GEOJSON_JDBC_URL')\nSAMPLE_GEOJSON_JDBC_DRIVER = os.environ.get('SAMPLE_GEOJSON_JDBC_DRIVER')\nSAMPLE_GEOJSON_JDBC_JARS = os.environ.get('SAMPLE_GEOJSON_JDBC_JARS')\nSAMPLE_GEOJSON_JDBC_USER = os.environ.get('SAMPLE_GEOJSON_JDBC_USER')\nSAMPLE_GEOJSON_JDBC_PASS = os.environ.get('SAMPLE_GEOJSON_JDBC_PASS')\n# Local file fallback\nSAMPLE_GEOJSON_PATH = os.path.join(os.path.dirname(__file__), 'data', 'sample_neighborhoods.geojson')\n_SAMPLE_CACHE = None\ndef load_sample_data():",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "SAMPLE_GEOJSON_JDBC_URL",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "SAMPLE_GEOJSON_JDBC_URL = os.environ.get('SAMPLE_GEOJSON_JDBC_URL')\nSAMPLE_GEOJSON_JDBC_DRIVER = os.environ.get('SAMPLE_GEOJSON_JDBC_DRIVER')\nSAMPLE_GEOJSON_JDBC_JARS = os.environ.get('SAMPLE_GEOJSON_JDBC_JARS')\nSAMPLE_GEOJSON_JDBC_USER = os.environ.get('SAMPLE_GEOJSON_JDBC_USER')\nSAMPLE_GEOJSON_JDBC_PASS = os.environ.get('SAMPLE_GEOJSON_JDBC_PASS')\n# Local file fallback\nSAMPLE_GEOJSON_PATH = os.path.join(os.path.dirname(__file__), 'data', 'sample_neighborhoods.geojson')\n_SAMPLE_CACHE = None\ndef load_sample_data():\n\t\"\"\"Load and cache sample GeoJSON file from the repository.\"\"\"",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "SAMPLE_GEOJSON_JDBC_DRIVER",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "SAMPLE_GEOJSON_JDBC_DRIVER = os.environ.get('SAMPLE_GEOJSON_JDBC_DRIVER')\nSAMPLE_GEOJSON_JDBC_JARS = os.environ.get('SAMPLE_GEOJSON_JDBC_JARS')\nSAMPLE_GEOJSON_JDBC_USER = os.environ.get('SAMPLE_GEOJSON_JDBC_USER')\nSAMPLE_GEOJSON_JDBC_PASS = os.environ.get('SAMPLE_GEOJSON_JDBC_PASS')\n# Local file fallback\nSAMPLE_GEOJSON_PATH = os.path.join(os.path.dirname(__file__), 'data', 'sample_neighborhoods.geojson')\n_SAMPLE_CACHE = None\ndef load_sample_data():\n\t\"\"\"Load and cache sample GeoJSON file from the repository.\"\"\"\n\tglobal _SAMPLE_CACHE",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "SAMPLE_GEOJSON_JDBC_JARS",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "SAMPLE_GEOJSON_JDBC_JARS = os.environ.get('SAMPLE_GEOJSON_JDBC_JARS')\nSAMPLE_GEOJSON_JDBC_USER = os.environ.get('SAMPLE_GEOJSON_JDBC_USER')\nSAMPLE_GEOJSON_JDBC_PASS = os.environ.get('SAMPLE_GEOJSON_JDBC_PASS')\n# Local file fallback\nSAMPLE_GEOJSON_PATH = os.path.join(os.path.dirname(__file__), 'data', 'sample_neighborhoods.geojson')\n_SAMPLE_CACHE = None\ndef load_sample_data():\n\t\"\"\"Load and cache sample GeoJSON file from the repository.\"\"\"\n\tglobal _SAMPLE_CACHE\n\tif _SAMPLE_CACHE is not None:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "SAMPLE_GEOJSON_JDBC_USER",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "SAMPLE_GEOJSON_JDBC_USER = os.environ.get('SAMPLE_GEOJSON_JDBC_USER')\nSAMPLE_GEOJSON_JDBC_PASS = os.environ.get('SAMPLE_GEOJSON_JDBC_PASS')\n# Local file fallback\nSAMPLE_GEOJSON_PATH = os.path.join(os.path.dirname(__file__), 'data', 'sample_neighborhoods.geojson')\n_SAMPLE_CACHE = None\ndef load_sample_data():\n\t\"\"\"Load and cache sample GeoJSON file from the repository.\"\"\"\n\tglobal _SAMPLE_CACHE\n\tif _SAMPLE_CACHE is not None:\n\t\treturn _SAMPLE_CACHE",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "SAMPLE_GEOJSON_JDBC_PASS",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "SAMPLE_GEOJSON_JDBC_PASS = os.environ.get('SAMPLE_GEOJSON_JDBC_PASS')\n# Local file fallback\nSAMPLE_GEOJSON_PATH = os.path.join(os.path.dirname(__file__), 'data', 'sample_neighborhoods.geojson')\n_SAMPLE_CACHE = None\ndef load_sample_data():\n\t\"\"\"Load and cache sample GeoJSON file from the repository.\"\"\"\n\tglobal _SAMPLE_CACHE\n\tif _SAMPLE_CACHE is not None:\n\t\treturn _SAMPLE_CACHE\n\t# First attempt: if JDBC + SQL specified, try to fetch features from DB",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "SAMPLE_GEOJSON_PATH",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "SAMPLE_GEOJSON_PATH = os.path.join(os.path.dirname(__file__), 'data', 'sample_neighborhoods.geojson')\n_SAMPLE_CACHE = None\ndef load_sample_data():\n\t\"\"\"Load and cache sample GeoJSON file from the repository.\"\"\"\n\tglobal _SAMPLE_CACHE\n\tif _SAMPLE_CACHE is not None:\n\t\treturn _SAMPLE_CACHE\n\t# First attempt: if JDBC + SQL specified, try to fetch features from DB\n\tif SAMPLE_GEOJSON_SQL and (_JDBC_AVAILABLE and SAMPLE_GEOJSON_JDBC_URL and SAMPLE_GEOJSON_JDBC_DRIVER):\n\t\ttry:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "_SAMPLE_CACHE",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "_SAMPLE_CACHE = None\ndef load_sample_data():\n\t\"\"\"Load and cache sample GeoJSON file from the repository.\"\"\"\n\tglobal _SAMPLE_CACHE\n\tif _SAMPLE_CACHE is not None:\n\t\treturn _SAMPLE_CACHE\n\t# First attempt: if JDBC + SQL specified, try to fetch features from DB\n\tif SAMPLE_GEOJSON_SQL and (_JDBC_AVAILABLE and SAMPLE_GEOJSON_JDBC_URL and SAMPLE_GEOJSON_JDBC_DRIVER):\n\t\ttry:\n\t\t\t# ensure JVM started if needed",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tjars",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\tjars = SAMPLE_GEOJSON_JDBC_JARS.split(os.pathsep)\n\t\t\t\t\tjpype.startJVM(classpath=jars)\n\t\t\t\telse:\n\t\t\t\t\t# start default JVM (may fail if no jars provided)\n\t\t\t\t\tjpype.startJVM()\n\t\t\tconn = jaydebeapi.connect(SAMPLE_GEOJSON_JDBC_DRIVER, SAMPLE_GEOJSON_JDBC_URL, [SAMPLE_GEOJSON_JDBC_USER, SAMPLE_GEOJSON_JDBC_PASS] if SAMPLE_GEOJSON_JDBC_USER else None, jars=SAMPLE_GEOJSON_JDBC_JARS.split(os.pathsep) if SAMPLE_GEOJSON_JDBC_JARS else None)\n\t\t\tcur = conn.cursor()\n\t\t\tcur.execute(SAMPLE_GEOJSON_SQL)\n\t\t\trows = cur.fetchall()\n\t\t\tfeatures = []",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tconn",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tconn = jaydebeapi.connect(SAMPLE_GEOJSON_JDBC_DRIVER, SAMPLE_GEOJSON_JDBC_URL, [SAMPLE_GEOJSON_JDBC_USER, SAMPLE_GEOJSON_JDBC_PASS] if SAMPLE_GEOJSON_JDBC_USER else None, jars=SAMPLE_GEOJSON_JDBC_JARS.split(os.pathsep) if SAMPLE_GEOJSON_JDBC_JARS else None)\n\t\t\tcur = conn.cursor()\n\t\t\tcur.execute(SAMPLE_GEOJSON_SQL)\n\t\t\trows = cur.fetchall()\n\t\t\tfeatures = []\n\t\t\tfor r in rows:\n\t\t\t\tcell = r[0] if isinstance(r, (list, tuple)) else r\n\t\t\t\tif isinstance(cell, (bytes, bytearray)):\n\t\t\t\t\tcell = cell.decode('utf-8')\n\t\t\t\ttry:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tcur",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tcur = conn.cursor()\n\t\t\tcur.execute(SAMPLE_GEOJSON_SQL)\n\t\t\trows = cur.fetchall()\n\t\t\tfeatures = []\n\t\t\tfor r in rows:\n\t\t\t\tcell = r[0] if isinstance(r, (list, tuple)) else r\n\t\t\t\tif isinstance(cell, (bytes, bytearray)):\n\t\t\t\t\tcell = cell.decode('utf-8')\n\t\t\t\ttry:\n\t\t\t\t\tobj = json.loads(cell)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\trows",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\trows = cur.fetchall()\n\t\t\tfeatures = []\n\t\t\tfor r in rows:\n\t\t\t\tcell = r[0] if isinstance(r, (list, tuple)) else r\n\t\t\t\tif isinstance(cell, (bytes, bytearray)):\n\t\t\t\t\tcell = cell.decode('utf-8')\n\t\t\t\ttry:\n\t\t\t\t\tobj = json.loads(cell)\n\t\t\t\t\t# If it's a FeatureCollection, extend\n\t\t\t\t\tif isinstance(obj, dict) and obj.get('type') == 'FeatureCollection' and isinstance(obj.get('features'), list):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tfeatures",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tfeatures = []\n\t\t\tfor r in rows:\n\t\t\t\tcell = r[0] if isinstance(r, (list, tuple)) else r\n\t\t\t\tif isinstance(cell, (bytes, bytearray)):\n\t\t\t\t\tcell = cell.decode('utf-8')\n\t\t\t\ttry:\n\t\t\t\t\tobj = json.loads(cell)\n\t\t\t\t\t# If it's a FeatureCollection, extend\n\t\t\t\t\tif isinstance(obj, dict) and obj.get('type') == 'FeatureCollection' and isinstance(obj.get('features'), list):\n\t\t\t\t\t\tfeatures.extend(obj.get('features'))",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tcell",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tcell = r[0] if isinstance(r, (list, tuple)) else r\n\t\t\t\tif isinstance(cell, (bytes, bytearray)):\n\t\t\t\t\tcell = cell.decode('utf-8')\n\t\t\t\ttry:\n\t\t\t\t\tobj = json.loads(cell)\n\t\t\t\t\t# If it's a FeatureCollection, extend\n\t\t\t\t\tif isinstance(obj, dict) and obj.get('type') == 'FeatureCollection' and isinstance(obj.get('features'), list):\n\t\t\t\t\t\tfeatures.extend(obj.get('features'))\n\t\t\t\t\telif isinstance(obj, dict) and obj.get('type') == 'Feature':\n\t\t\t\t\t\tfeatures.append(obj)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tcell",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\tcell = cell.decode('utf-8')\n\t\t\t\ttry:\n\t\t\t\t\tobj = json.loads(cell)\n\t\t\t\t\t# If it's a FeatureCollection, extend\n\t\t\t\t\tif isinstance(obj, dict) and obj.get('type') == 'FeatureCollection' and isinstance(obj.get('features'), list):\n\t\t\t\t\t\tfeatures.extend(obj.get('features'))\n\t\t\t\t\telif isinstance(obj, dict) and obj.get('type') == 'Feature':\n\t\t\t\t\t\tfeatures.append(obj)\n\t\t\t\t\telif isinstance(obj, dict):\n\t\t\t\t\t\t# treat dict as properties-only feature",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tobj",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\tobj = json.loads(cell)\n\t\t\t\t\t# If it's a FeatureCollection, extend\n\t\t\t\t\tif isinstance(obj, dict) and obj.get('type') == 'FeatureCollection' and isinstance(obj.get('features'), list):\n\t\t\t\t\t\tfeatures.extend(obj.get('features'))\n\t\t\t\t\telif isinstance(obj, dict) and obj.get('type') == 'Feature':\n\t\t\t\t\t\tfeatures.append(obj)\n\t\t\t\t\telif isinstance(obj, dict):\n\t\t\t\t\t\t# treat dict as properties-only feature\n\t\t\t\t\t\tfeatures.append({'type': 'Feature', 'properties': obj})\n\t\t\t\t\telse:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\t\tkeys",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\t\t\tkeys = [c[0] for c in cur.description]\n\t\t\t\t\t\t\tprops = {keys[i]: r[i] for i in range(min(len(keys), len(r)))}\n\t\t\t\t\t\t\tfeatures.append({'type': 'Feature', 'properties': props})\n\t\t\t\t\t\texcept Exception:\n\t\t\t\t\t\t\tcontinue\n\t\t\tcur.close()\n\t\t\tconn.close()\n\t\t\t_SAMPLE_CACHE = {'type': 'FeatureCollection', 'features': features}\n\t\t\treturn _SAMPLE_CACHE\n\t\texcept Exception as e:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\t\tprops",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\t\t\tprops = {keys[i]: r[i] for i in range(min(len(keys), len(r)))}\n\t\t\t\t\t\t\tfeatures.append({'type': 'Feature', 'properties': props})\n\t\t\t\t\t\texcept Exception:\n\t\t\t\t\t\t\tcontinue\n\t\t\tcur.close()\n\t\t\tconn.close()\n\t\t\t_SAMPLE_CACHE = {'type': 'FeatureCollection', 'features': features}\n\t\t\treturn _SAMPLE_CACHE\n\t\texcept Exception as e:\n\t\t\t# log and fall back to file",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t_SAMPLE_CACHE",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t_SAMPLE_CACHE = {'type': 'FeatureCollection', 'features': features}\n\t\t\treturn _SAMPLE_CACHE\n\t\texcept Exception as e:\n\t\t\t# log and fall back to file\n\t\t\ttry:\n\t\t\t\tapp.logger.exception('failed to load sample data from JDBC: %s', e)\n\t\t\texcept Exception:\n\t\t\t\tpass\n\t# Fallback to local file\n\tif not os.path.isfile(SAMPLE_GEOJSON_PATH):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t_SAMPLE_CACHE",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t_SAMPLE_CACHE = { 'features': [] }\n\t\treturn _SAMPLE_CACHE\n\twith open(SAMPLE_GEOJSON_PATH, 'r', encoding='utf-8') as fh:\n\t\t_SAMPLE_CACHE = json.load(fh)\n\treturn _SAMPLE_CACHE\ndef query_sample_sum(neighborhood_field, neighborhood_value, population_field):\n\t\"\"\"Query the local sample GeoJSON and sum population for matching neighborhood name.\"\"\"\n\tdata = load_sample_data()\n\ttotal = 0\n\tcount = 0",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t_SAMPLE_CACHE",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t_SAMPLE_CACHE = json.load(fh)\n\treturn _SAMPLE_CACHE\ndef query_sample_sum(neighborhood_field, neighborhood_value, population_field):\n\t\"\"\"Query the local sample GeoJSON and sum population for matching neighborhood name.\"\"\"\n\tdata = load_sample_data()\n\ttotal = 0\n\tcount = 0\n\tneedle = str(neighborhood_value).strip().lower()\n\tfor feat in data.get('features', []):\n\t\tprops = feat.get('properties', {})",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tdata",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tdata = load_sample_data()\n\ttotal = 0\n\tcount = 0\n\tneedle = str(neighborhood_value).strip().lower()\n\tfor feat in data.get('features', []):\n\t\tprops = feat.get('properties', {})\n\t\t# try multiple candidate name fields (case-insensitive)\n\t\tcandidates = []\n\t\tfor k in [neighborhood_field, neighborhood_field.upper(), neighborhood_field.lower(), 'NAME', 'name', 'EN_NAME', 'en_name']:\n\t\t\tv = props.get(k)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\ttotal",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\ttotal = 0\n\tcount = 0\n\tneedle = str(neighborhood_value).strip().lower()\n\tfor feat in data.get('features', []):\n\t\tprops = feat.get('properties', {})\n\t\t# try multiple candidate name fields (case-insensitive)\n\t\tcandidates = []\n\t\tfor k in [neighborhood_field, neighborhood_field.upper(), neighborhood_field.lower(), 'NAME', 'name', 'EN_NAME', 'en_name']:\n\t\t\tv = props.get(k)\n\t\t\tif v:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tcount",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tcount = 0\n\tneedle = str(neighborhood_value).strip().lower()\n\tfor feat in data.get('features', []):\n\t\tprops = feat.get('properties', {})\n\t\t# try multiple candidate name fields (case-insensitive)\n\t\tcandidates = []\n\t\tfor k in [neighborhood_field, neighborhood_field.upper(), neighborhood_field.lower(), 'NAME', 'name', 'EN_NAME', 'en_name']:\n\t\t\tv = props.get(k)\n\t\t\tif v:\n\t\t\t\tcandidates.append(str(v).strip().lower())",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tneedle",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tneedle = str(neighborhood_value).strip().lower()\n\tfor feat in data.get('features', []):\n\t\tprops = feat.get('properties', {})\n\t\t# try multiple candidate name fields (case-insensitive)\n\t\tcandidates = []\n\t\tfor k in [neighborhood_field, neighborhood_field.upper(), neighborhood_field.lower(), 'NAME', 'name', 'EN_NAME', 'en_name']:\n\t\t\tv = props.get(k)\n\t\t\tif v:\n\t\t\t\tcandidates.append(str(v).strip().lower())\n\t\tmatched = False",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tprops",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tprops = feat.get('properties', {})\n\t\t# try multiple candidate name fields (case-insensitive)\n\t\tcandidates = []\n\t\tfor k in [neighborhood_field, neighborhood_field.upper(), neighborhood_field.lower(), 'NAME', 'name', 'EN_NAME', 'en_name']:\n\t\t\tv = props.get(k)\n\t\t\tif v:\n\t\t\t\tcandidates.append(str(v).strip().lower())\n\t\tmatched = False\n\t\tfor cand in candidates:\n\t\t\tif cand == needle:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tcandidates",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tcandidates = []\n\t\tfor k in [neighborhood_field, neighborhood_field.upper(), neighborhood_field.lower(), 'NAME', 'name', 'EN_NAME', 'en_name']:\n\t\t\tv = props.get(k)\n\t\t\tif v:\n\t\t\t\tcandidates.append(str(v).strip().lower())\n\t\tmatched = False\n\t\tfor cand in candidates:\n\t\t\tif cand == needle:\n\t\t\t\tmatched = True\n\t\t\t\tbreak",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tv",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tv = props.get(k)\n\t\t\tif v:\n\t\t\t\tcandidates.append(str(v).strip().lower())\n\t\tmatched = False\n\t\tfor cand in candidates:\n\t\t\tif cand == needle:\n\t\t\t\tmatched = True\n\t\t\t\tbreak\n\t\tif not matched:\n\t\t\t# also allow looser match: spaces/hyphens normalized",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tmatched",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tmatched = False\n\t\tfor cand in candidates:\n\t\t\tif cand == needle:\n\t\t\t\tmatched = True\n\t\t\t\tbreak\n\t\tif not matched:\n\t\t\t# also allow looser match: spaces/hyphens normalized\n\t\t\tnorm_needle = needle.replace('-', ' ').replace('_', ' ')\n\t\t\tfor cand in candidates:\n\t\t\t\tif cand.replace('-', ' ').replace('_', ' ') == norm_needle:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tmatched",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tmatched = True\n\t\t\t\tbreak\n\t\tif not matched:\n\t\t\t# also allow looser match: spaces/hyphens normalized\n\t\t\tnorm_needle = needle.replace('-', ' ').replace('_', ' ')\n\t\t\tfor cand in candidates:\n\t\t\t\tif cand.replace('-', ' ').replace('_', ' ') == norm_needle:\n\t\t\t\t\tmatched = True\n\t\t\t\t\tbreak\n\t\tif not matched:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tnorm_needle",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tnorm_needle = needle.replace('-', ' ').replace('_', ' ')\n\t\t\tfor cand in candidates:\n\t\t\t\tif cand.replace('-', ' ').replace('_', ' ') == norm_needle:\n\t\t\t\t\tmatched = True\n\t\t\t\t\tbreak\n\t\tif not matched:\n\t\t\tcontinue\n\t\tval = props.get(population_field) or props.get(population_field.upper()) or props.get('POP') or props.get('pop')\n\t\ttry:\n\t\t\tif val is None:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tmatched",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\tmatched = True\n\t\t\t\t\tbreak\n\t\tif not matched:\n\t\t\tcontinue\n\t\tval = props.get(population_field) or props.get(population_field.upper()) or props.get('POP') or props.get('pop')\n\t\ttry:\n\t\t\tif val is None:\n\t\t\t\tcontinue\n\t\t\ttotal += float(val)\n\t\t\tcount += 1",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tval",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tval = props.get(population_field) or props.get(population_field.upper()) or props.get('POP') or props.get('pop')\n\t\ttry:\n\t\t\tif val is None:\n\t\t\t\tcontinue\n\t\t\ttotal += float(val)\n\t\t\tcount += 1\n\t\texcept Exception:\n\t\t\tcontinue\n\treturn {\n\t\t'neighborhood': neighborhood_value,",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tdata",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tdata = load_sample_data()\n\tneedle = str(neighborhood_value).strip().lower()\n\tfor feat in data.get('features', []):\n\t\tprops = feat.get('properties', {})\n\t\tcandidates = []\n\t\tfor k in [neighborhood_field, neighborhood_field.upper(), neighborhood_field.lower(), 'NAME', 'name', 'EN_NAME', 'en_name']:\n\t\t\tv = props.get(k)\n\t\t\tif v:\n\t\t\t\tcandidates.append(str(v).strip().lower())\n\t\tmatched = False",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tneedle",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tneedle = str(neighborhood_value).strip().lower()\n\tfor feat in data.get('features', []):\n\t\tprops = feat.get('properties', {})\n\t\tcandidates = []\n\t\tfor k in [neighborhood_field, neighborhood_field.upper(), neighborhood_field.lower(), 'NAME', 'name', 'EN_NAME', 'en_name']:\n\t\t\tv = props.get(k)\n\t\t\tif v:\n\t\t\t\tcandidates.append(str(v).strip().lower())\n\t\tmatched = False\n\t\tfor cand in candidates:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tprops",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tprops = feat.get('properties', {})\n\t\tcandidates = []\n\t\tfor k in [neighborhood_field, neighborhood_field.upper(), neighborhood_field.lower(), 'NAME', 'name', 'EN_NAME', 'en_name']:\n\t\t\tv = props.get(k)\n\t\t\tif v:\n\t\t\t\tcandidates.append(str(v).strip().lower())\n\t\tmatched = False\n\t\tfor cand in candidates:\n\t\t\tif cand == needle:\n\t\t\t\tmatched = True",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tcandidates",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tcandidates = []\n\t\tfor k in [neighborhood_field, neighborhood_field.upper(), neighborhood_field.lower(), 'NAME', 'name', 'EN_NAME', 'en_name']:\n\t\t\tv = props.get(k)\n\t\t\tif v:\n\t\t\t\tcandidates.append(str(v).strip().lower())\n\t\tmatched = False\n\t\tfor cand in candidates:\n\t\t\tif cand == needle:\n\t\t\t\tmatched = True\n\t\t\t\tbreak",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tv",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tv = props.get(k)\n\t\t\tif v:\n\t\t\t\tcandidates.append(str(v).strip().lower())\n\t\tmatched = False\n\t\tfor cand in candidates:\n\t\t\tif cand == needle:\n\t\t\t\tmatched = True\n\t\t\t\tbreak\n\t\tif not matched:\n\t\t\tnorm_needle = needle.replace('-', ' ').replace('_', ' ')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tmatched",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tmatched = False\n\t\tfor cand in candidates:\n\t\t\tif cand == needle:\n\t\t\t\tmatched = True\n\t\t\t\tbreak\n\t\tif not matched:\n\t\t\tnorm_needle = needle.replace('-', ' ').replace('_', ' ')\n\t\t\tfor cand in candidates:\n\t\t\t\tif cand.replace('-', ' ').replace('_', ' ') == norm_needle:\n\t\t\t\t\tmatched = True",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tmatched",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tmatched = True\n\t\t\t\tbreak\n\t\tif not matched:\n\t\t\tnorm_needle = needle.replace('-', ' ').replace('_', ' ')\n\t\t\tfor cand in candidates:\n\t\t\t\tif cand.replace('-', ' ').replace('_', ' ') == norm_needle:\n\t\t\t\t\tmatched = True\n\t\t\t\t\tbreak\n\t\tif not matched:\n\t\t\tcontinue",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tnorm_needle",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tnorm_needle = needle.replace('-', ' ').replace('_', ' ')\n\t\t\tfor cand in candidates:\n\t\t\t\tif cand.replace('-', ' ').replace('_', ' ') == norm_needle:\n\t\t\t\t\tmatched = True\n\t\t\t\t\tbreak\n\t\tif not matched:\n\t\t\tcontinue\n\t\t# found a matching feature\n\t\tpop_m = props.get('POP_M') or props.get('pop_m') or 0\n\t\tpop_f = props.get('POP_F') or props.get('pop_f') or 0",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tmatched",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\tmatched = True\n\t\t\t\t\tbreak\n\t\tif not matched:\n\t\t\tcontinue\n\t\t# found a matching feature\n\t\tpop_m = props.get('POP_M') or props.get('pop_m') or 0\n\t\tpop_f = props.get('POP_F') or props.get('pop_f') or 0\n\t\ttry:\n\t\t\tpop_m = float(pop_m)\n\t\texcept Exception:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tpop_m",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tpop_m = props.get('POP_M') or props.get('pop_m') or 0\n\t\tpop_f = props.get('POP_F') or props.get('pop_f') or 0\n\t\ttry:\n\t\t\tpop_m = float(pop_m)\n\t\texcept Exception:\n\t\t\tpop_m = 0\n\t\ttry:\n\t\t\tpop_f = float(pop_f)\n\t\texcept Exception:\n\t\t\tpop_f = 0",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tpop_f",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tpop_f = props.get('POP_F') or props.get('pop_f') or 0\n\t\ttry:\n\t\t\tpop_m = float(pop_m)\n\t\texcept Exception:\n\t\t\tpop_m = 0\n\t\ttry:\n\t\t\tpop_f = float(pop_f)\n\t\texcept Exception:\n\t\t\tpop_f = 0\n\t\t# return the feature and counts",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tpop_m",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tpop_m = float(pop_m)\n\t\texcept Exception:\n\t\t\tpop_m = 0\n\t\ttry:\n\t\t\tpop_f = float(pop_f)\n\t\texcept Exception:\n\t\t\tpop_f = 0\n\t\t# return the feature and counts\n\t\treturn {\n\t\t\t'neighborhood': props.get('EN_NAME') or props.get('NAME') or neighborhood_value,",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tpop_m",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tpop_m = 0\n\t\ttry:\n\t\t\tpop_f = float(pop_f)\n\t\texcept Exception:\n\t\t\tpop_f = 0\n\t\t# return the feature and counts\n\t\treturn {\n\t\t\t'neighborhood': props.get('EN_NAME') or props.get('NAME') or neighborhood_value,\n\t\t\t'population_male': pop_m,\n\t\t\t'population_female': pop_f,",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tpop_f",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tpop_f = float(pop_f)\n\t\texcept Exception:\n\t\t\tpop_f = 0\n\t\t# return the feature and counts\n\t\treturn {\n\t\t\t'neighborhood': props.get('EN_NAME') or props.get('NAME') or neighborhood_value,\n\t\t\t'population_male': pop_m,\n\t\t\t'population_female': pop_f,\n\t\t\t'population_total': pop_m + pop_f,\n\t\t\t'feature': feat",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tpop_f",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tpop_f = 0\n\t\t# return the feature and counts\n\t\treturn {\n\t\t\t'neighborhood': props.get('EN_NAME') or props.get('NAME') or neighborhood_value,\n\t\t\t'population_male': pop_m,\n\t\t\t'population_female': pop_f,\n\t\t\t'population_total': pop_m + pop_f,\n\t\t\t'feature': feat\n\t\t}\n\treturn None",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tdata",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tdata = load_sample_data()\n\tgroups = {}\n\tfor feat in data.get('features', []):\n\t\tprops = feat.get('properties', {})\n\t\t# prefer Arabic NAME, fall back to EN_NAME\n\t\tname = props.get(neighborhood_field) or props.get('NAME') or props.get('name') or props.get('EN_NAME')\n\t\tif not name:\n\t\t\tcontinue\n\t\tval = props.get(population_field) or props.get('POP') or props.get('pop')\n\t\ttry:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tgroups",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tgroups = {}\n\tfor feat in data.get('features', []):\n\t\tprops = feat.get('properties', {})\n\t\t# prefer Arabic NAME, fall back to EN_NAME\n\t\tname = props.get(neighborhood_field) or props.get('NAME') or props.get('name') or props.get('EN_NAME')\n\t\tif not name:\n\t\t\tcontinue\n\t\tval = props.get(population_field) or props.get('POP') or props.get('pop')\n\t\ttry:\n\t\t\tv = float(val) if val is not None else 0",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tprops",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tprops = feat.get('properties', {})\n\t\t# prefer Arabic NAME, fall back to EN_NAME\n\t\tname = props.get(neighborhood_field) or props.get('NAME') or props.get('name') or props.get('EN_NAME')\n\t\tif not name:\n\t\t\tcontinue\n\t\tval = props.get(population_field) or props.get('POP') or props.get('pop')\n\t\ttry:\n\t\t\tv = float(val) if val is not None else 0\n\t\texcept Exception:\n\t\t\tv = 0",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tname",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tname = props.get(neighborhood_field) or props.get('NAME') or props.get('name') or props.get('EN_NAME')\n\t\tif not name:\n\t\t\tcontinue\n\t\tval = props.get(population_field) or props.get('POP') or props.get('pop')\n\t\ttry:\n\t\t\tv = float(val) if val is not None else 0\n\t\texcept Exception:\n\t\t\tv = 0\n\t\tgroups[name] = groups.get(name, 0) + v\n\tstats = []",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tval",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tval = props.get(population_field) or props.get('POP') or props.get('pop')\n\t\ttry:\n\t\t\tv = float(val) if val is not None else 0\n\t\texcept Exception:\n\t\t\tv = 0\n\t\tgroups[name] = groups.get(name, 0) + v\n\tstats = []\n\tfor k, v in groups.items():\n\t\tstats.append({'neighborhood': k, 'population_sum': v})\n\treturn sorted(stats, key=lambda x: x['population_sum'], reverse=True)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tv",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tv = float(val) if val is not None else 0\n\t\texcept Exception:\n\t\t\tv = 0\n\t\tgroups[name] = groups.get(name, 0) + v\n\tstats = []\n\tfor k, v in groups.items():\n\t\tstats.append({'neighborhood': k, 'population_sum': v})\n\treturn sorted(stats, key=lambda x: x['population_sum'], reverse=True)\n# Note: Removed use of `data/SA_regions.json` as requested. We'll search the\n# allowed external files (geojson/ and json/) instead.",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tv",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tv = 0\n\t\tgroups[name] = groups.get(name, 0) + v\n\tstats = []\n\tfor k, v in groups.items():\n\t\tstats.append({'neighborhood': k, 'population_sum': v})\n\treturn sorted(stats, key=lambda x: x['population_sum'], reverse=True)\n# Note: Removed use of `data/SA_regions.json` as requested. We'll search the\n# allowed external files (geojson/ and json/) instead.\n# Optional region population mapping (local test data)\nREGION_POP_PATH = os.path.join(os.path.dirname(__file__), 'data', 'region_population.json')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tgroups[name]",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tgroups[name] = groups.get(name, 0) + v\n\tstats = []\n\tfor k, v in groups.items():\n\t\tstats.append({'neighborhood': k, 'population_sum': v})\n\treturn sorted(stats, key=lambda x: x['population_sum'], reverse=True)\n# Note: Removed use of `data/SA_regions.json` as requested. We'll search the\n# allowed external files (geojson/ and json/) instead.\n# Optional region population mapping (local test data)\nREGION_POP_PATH = os.path.join(os.path.dirname(__file__), 'data', 'region_population.json')\n_REGION_POP_CACHE = None",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tstats",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tstats = []\n\tfor k, v in groups.items():\n\t\tstats.append({'neighborhood': k, 'population_sum': v})\n\treturn sorted(stats, key=lambda x: x['population_sum'], reverse=True)\n# Note: Removed use of `data/SA_regions.json` as requested. We'll search the\n# allowed external files (geojson/ and json/) instead.\n# Optional region population mapping (local test data)\nREGION_POP_PATH = os.path.join(os.path.dirname(__file__), 'data', 'region_population.json')\n_REGION_POP_CACHE = None\ndef load_region_populations():",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "REGION_POP_PATH",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "REGION_POP_PATH = os.path.join(os.path.dirname(__file__), 'data', 'region_population.json')\n_REGION_POP_CACHE = None\ndef load_region_populations():\n\tglobal _REGION_POP_CACHE\n\tif _REGION_POP_CACHE is not None:\n\t\treturn _REGION_POP_CACHE\n\tif not os.path.isfile(REGION_POP_PATH):\n\t\t_REGION_POP_CACHE = {}\n\t\treturn _REGION_POP_CACHE\n\twith open(REGION_POP_PATH, 'r', encoding='utf-8') as fh:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "_REGION_POP_CACHE",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "_REGION_POP_CACHE = None\ndef load_region_populations():\n\tglobal _REGION_POP_CACHE\n\tif _REGION_POP_CACHE is not None:\n\t\treturn _REGION_POP_CACHE\n\tif not os.path.isfile(REGION_POP_PATH):\n\t\t_REGION_POP_CACHE = {}\n\t\treturn _REGION_POP_CACHE\n\twith open(REGION_POP_PATH, 'r', encoding='utf-8') as fh:\n\t\t_REGION_POP_CACHE = json.load(fh)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t_REGION_POP_CACHE",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t_REGION_POP_CACHE = {}\n\t\treturn _REGION_POP_CACHE\n\twith open(REGION_POP_PATH, 'r', encoding='utf-8') as fh:\n\t\t_REGION_POP_CACHE = json.load(fh)\n\treturn _REGION_POP_CACHE\n# Population DB support: prefer JDBC when configured, otherwise fallback to sqlite\n# Environment variables for JDBC:\n#  POP_JDBC_URL, POP_JDBC_DRIVER, POP_JDBC_JARS, POP_JDBC_USER, POP_JDBC_PASS\nPOP_JDBC_URL = os.environ.get('POP_JDBC_URL')\nPOP_JDBC_DRIVER = os.environ.get('POP_JDBC_DRIVER')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t_REGION_POP_CACHE",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t_REGION_POP_CACHE = json.load(fh)\n\treturn _REGION_POP_CACHE\n# Population DB support: prefer JDBC when configured, otherwise fallback to sqlite\n# Environment variables for JDBC:\n#  POP_JDBC_URL, POP_JDBC_DRIVER, POP_JDBC_JARS, POP_JDBC_USER, POP_JDBC_PASS\nPOP_JDBC_URL = os.environ.get('POP_JDBC_URL')\nPOP_JDBC_DRIVER = os.environ.get('POP_JDBC_DRIVER')\nPOP_JDBC_JARS = os.environ.get('POP_JDBC_JARS')\nPOP_JDBC_USER = os.environ.get('POP_JDBC_USER')\nPOP_JDBC_PASS = os.environ.get('POP_JDBC_PASS')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "POP_JDBC_URL",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "POP_JDBC_URL = os.environ.get('POP_JDBC_URL')\nPOP_JDBC_DRIVER = os.environ.get('POP_JDBC_DRIVER')\nPOP_JDBC_JARS = os.environ.get('POP_JDBC_JARS')\nPOP_JDBC_USER = os.environ.get('POP_JDBC_USER')\nPOP_JDBC_PASS = os.environ.get('POP_JDBC_PASS')\n# Fallback sqlite path (used when JDBC not configured)\nPOP_DB_PATH = os.environ.get('POP_DB') or os.path.join(os.path.dirname(__file__), 'data', 'population.db')\ndef _start_jvm_if_needed(jars_str):\n\tif not _JDBC_AVAILABLE:\n\t\treturn",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "POP_JDBC_DRIVER",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "POP_JDBC_DRIVER = os.environ.get('POP_JDBC_DRIVER')\nPOP_JDBC_JARS = os.environ.get('POP_JDBC_JARS')\nPOP_JDBC_USER = os.environ.get('POP_JDBC_USER')\nPOP_JDBC_PASS = os.environ.get('POP_JDBC_PASS')\n# Fallback sqlite path (used when JDBC not configured)\nPOP_DB_PATH = os.environ.get('POP_DB') or os.path.join(os.path.dirname(__file__), 'data', 'population.db')\ndef _start_jvm_if_needed(jars_str):\n\tif not _JDBC_AVAILABLE:\n\t\treturn\n\tif not jpype.isJVMStarted():",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "POP_JDBC_JARS",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "POP_JDBC_JARS = os.environ.get('POP_JDBC_JARS')\nPOP_JDBC_USER = os.environ.get('POP_JDBC_USER')\nPOP_JDBC_PASS = os.environ.get('POP_JDBC_PASS')\n# Fallback sqlite path (used when JDBC not configured)\nPOP_DB_PATH = os.environ.get('POP_DB') or os.path.join(os.path.dirname(__file__), 'data', 'population.db')\ndef _start_jvm_if_needed(jars_str):\n\tif not _JDBC_AVAILABLE:\n\t\treturn\n\tif not jpype.isJVMStarted():\n\t\tif jars_str:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "POP_JDBC_USER",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "POP_JDBC_USER = os.environ.get('POP_JDBC_USER')\nPOP_JDBC_PASS = os.environ.get('POP_JDBC_PASS')\n# Fallback sqlite path (used when JDBC not configured)\nPOP_DB_PATH = os.environ.get('POP_DB') or os.path.join(os.path.dirname(__file__), 'data', 'population.db')\ndef _start_jvm_if_needed(jars_str):\n\tif not _JDBC_AVAILABLE:\n\t\treturn\n\tif not jpype.isJVMStarted():\n\t\tif jars_str:\n\t\t\tjars = jars_str.split(os.pathsep)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "POP_JDBC_PASS",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "POP_JDBC_PASS = os.environ.get('POP_JDBC_PASS')\n# Fallback sqlite path (used when JDBC not configured)\nPOP_DB_PATH = os.environ.get('POP_DB') or os.path.join(os.path.dirname(__file__), 'data', 'population.db')\ndef _start_jvm_if_needed(jars_str):\n\tif not _JDBC_AVAILABLE:\n\t\treturn\n\tif not jpype.isJVMStarted():\n\t\tif jars_str:\n\t\t\tjars = jars_str.split(os.pathsep)\n\t\t\tjpype.startJVM(classpath=jars)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "POP_DB_PATH",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "POP_DB_PATH = os.environ.get('POP_DB') or os.path.join(os.path.dirname(__file__), 'data', 'population.db')\ndef _start_jvm_if_needed(jars_str):\n\tif not _JDBC_AVAILABLE:\n\t\treturn\n\tif not jpype.isJVMStarted():\n\t\tif jars_str:\n\t\t\tjars = jars_str.split(os.pathsep)\n\t\t\tjpype.startJVM(classpath=jars)\n\t\telse:\n\t\t\t# try starting default JVM",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tjars",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tjars = jars_str.split(os.pathsep)\n\t\t\tjpype.startJVM(classpath=jars)\n\t\telse:\n\t\t\t# try starting default JVM\n\t\t\tjpype.startJVM()\ndef _get_db_connection():\n\t\"\"\"Return a DB connection. If JDBC configured and available, returns a jaydebeapi connection.\n\tOtherwise returns sqlite3.Connection or None.\n\t\"\"\"\n\t# Try JDBC first",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tjars",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tjars = POP_JDBC_JARS.split(os.pathsep) if POP_JDBC_JARS else None\n\t\t\tconn = jaydebeapi.connect(POP_JDBC_DRIVER, POP_JDBC_URL, [POP_JDBC_USER, POP_JDBC_PASS] if POP_JDBC_USER else None, jars=jars)\n\t\t\treturn conn\n\t\texcept Exception as e:\n\t\t\ttry:\n\t\t\t\tapp.logger.exception('JDBC connection failed: %s', e)\n\t\t\texcept Exception:\n\t\t\t\tpass\n\t# Fallback to sqlite\n\ttry:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tconn",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tconn = jaydebeapi.connect(POP_JDBC_DRIVER, POP_JDBC_URL, [POP_JDBC_USER, POP_JDBC_PASS] if POP_JDBC_USER else None, jars=jars)\n\t\t\treturn conn\n\t\texcept Exception as e:\n\t\t\ttry:\n\t\t\t\tapp.logger.exception('JDBC connection failed: %s', e)\n\t\t\texcept Exception:\n\t\t\t\tpass\n\t# Fallback to sqlite\n\ttry:\n\t\tif not POP_DB_PATH or not os.path.isfile(POP_DB_PATH):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tconn",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tconn = sqlite3.connect(POP_DB_PATH)\n\t\tconn.row_factory = sqlite3.Row\n\t\treturn conn\n\texcept Exception:\n\t\treturn None\ndef _row_to_dict(cursor, row):\n\t\"\"\"Convert a DB row to a dict using cursor.description when needed.\"\"\"\n\tif row is None:\n\t\treturn None\n\t# sqlite3.Row is dict-like",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tconn.row_factory",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tconn.row_factory = sqlite3.Row\n\t\treturn conn\n\texcept Exception:\n\t\treturn None\ndef _row_to_dict(cursor, row):\n\t\"\"\"Convert a DB row to a dict using cursor.description when needed.\"\"\"\n\tif row is None:\n\t\treturn None\n\t# sqlite3.Row is dict-like\n\ttry:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tcols",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tcols = [c[0] for c in cursor.description]\n\t\treturn {cols[i]: row[i] for i in range(min(len(cols), len(row)))}\n\texcept Exception:\n\t\t# last resort: try to coerce sequence to dict with numeric keys\n\t\ttry:\n\t\t\treturn {str(i): row[i] for i in range(len(row))}\n\t\texcept Exception:\n\t\t\treturn None\ndef query_population_by_ids(region_id=None, city_id=None, district_id=None):\n\t\"\"\"Query population table prioritizing district -> city -> region.",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tconn",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tconn = _get_db_connection()\n\tif not conn:\n\t\treturn None\n\tcur = None\n\ttry:\n\t\tcur = conn.cursor()\n\t\t# helper to run a param query and coerce row to dict\n\t\tdef run_query_single(q, params):\n\t\t\ttry:\n\t\t\t\tcur.execute(q, params if params is not None else [])",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tcur",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tcur = None\n\ttry:\n\t\tcur = conn.cursor()\n\t\t# helper to run a param query and coerce row to dict\n\t\tdef run_query_single(q, params):\n\t\t\ttry:\n\t\t\t\tcur.execute(q, params if params is not None else [])\n\t\t\t\trow = cur.fetchone()\n\t\t\t\trowd = _row_to_dict(cur, row)\n\t\t\t\tif rowd:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tcur",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tcur = conn.cursor()\n\t\t# helper to run a param query and coerce row to dict\n\t\tdef run_query_single(q, params):\n\t\t\ttry:\n\t\t\t\tcur.execute(q, params if params is not None else [])\n\t\t\t\trow = cur.fetchone()\n\t\t\t\trowd = _row_to_dict(cur, row)\n\t\t\t\tif rowd:\n\t\t\t\t\tpop_m = float(rowd.get('pop_m') or rowd.get('POP_M') or 0)\n\t\t\t\t\tpop_f = float(rowd.get('pop_f') or rowd.get('POP_F') or 0)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\trow",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\trow = cur.fetchone()\n\t\t\t\trowd = _row_to_dict(cur, row)\n\t\t\t\tif rowd:\n\t\t\t\t\tpop_m = float(rowd.get('pop_m') or rowd.get('POP_M') or 0)\n\t\t\t\t\tpop_f = float(rowd.get('pop_f') or rowd.get('POP_F') or 0)\n\t\t\t\t\tpop_total = float(rowd.get('pop_total') or rowd.get('POP_TOTAL') or (pop_m + pop_f))\n\t\t\t\t\treturn {'population_male': pop_m, 'population_female': pop_f, 'population_total': pop_total}\n\t\t\texcept Exception:\n\t\t\t\treturn None\n\t\t\treturn None",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\trowd",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\trowd = _row_to_dict(cur, row)\n\t\t\t\tif rowd:\n\t\t\t\t\tpop_m = float(rowd.get('pop_m') or rowd.get('POP_M') or 0)\n\t\t\t\t\tpop_f = float(rowd.get('pop_f') or rowd.get('POP_F') or 0)\n\t\t\t\t\tpop_total = float(rowd.get('pop_total') or rowd.get('POP_TOTAL') or (pop_m + pop_f))\n\t\t\t\t\treturn {'population_male': pop_m, 'population_female': pop_f, 'population_total': pop_total}\n\t\t\texcept Exception:\n\t\t\t\treturn None\n\t\t\treturn None\n\t\tif district_id:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tpop_m",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\tpop_m = float(rowd.get('pop_m') or rowd.get('POP_M') or 0)\n\t\t\t\t\tpop_f = float(rowd.get('pop_f') or rowd.get('POP_F') or 0)\n\t\t\t\t\tpop_total = float(rowd.get('pop_total') or rowd.get('POP_TOTAL') or (pop_m + pop_f))\n\t\t\t\t\treturn {'population_male': pop_m, 'population_female': pop_f, 'population_total': pop_total}\n\t\t\texcept Exception:\n\t\t\t\treturn None\n\t\t\treturn None\n\t\tif district_id:\n\t\t\tres = run_query_single('SELECT pop_m, pop_f, pop_total FROM population WHERE district_id = ? LIMIT 1', (district_id,))\n\t\t\tif res:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tpop_f",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\tpop_f = float(rowd.get('pop_f') or rowd.get('POP_F') or 0)\n\t\t\t\t\tpop_total = float(rowd.get('pop_total') or rowd.get('POP_TOTAL') or (pop_m + pop_f))\n\t\t\t\t\treturn {'population_male': pop_m, 'population_female': pop_f, 'population_total': pop_total}\n\t\t\texcept Exception:\n\t\t\t\treturn None\n\t\t\treturn None\n\t\tif district_id:\n\t\t\tres = run_query_single('SELECT pop_m, pop_f, pop_total FROM population WHERE district_id = ? LIMIT 1', (district_id,))\n\t\t\tif res:\n\t\t\t\treturn res",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tpop_total",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\tpop_total = float(rowd.get('pop_total') or rowd.get('POP_TOTAL') or (pop_m + pop_f))\n\t\t\t\t\treturn {'population_male': pop_m, 'population_female': pop_f, 'population_total': pop_total}\n\t\t\texcept Exception:\n\t\t\t\treturn None\n\t\t\treturn None\n\t\tif district_id:\n\t\t\tres = run_query_single('SELECT pop_m, pop_f, pop_total FROM population WHERE district_id = ? LIMIT 1', (district_id,))\n\t\t\tif res:\n\t\t\t\treturn res\n\t\tif city_id:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tres",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tres = run_query_single('SELECT pop_m, pop_f, pop_total FROM population WHERE district_id = ? LIMIT 1', (district_id,))\n\t\t\tif res:\n\t\t\t\treturn res\n\t\tif city_id:\n\t\t\tres = run_query_single('SELECT pop_m, pop_f, pop_total FROM population WHERE city_id = ? LIMIT 1', (city_id,))\n\t\t\tif res:\n\t\t\t\treturn res\n\t\tif region_id:\n\t\t\tres = run_query_single('SELECT pop_m, pop_f, pop_total FROM population WHERE region_id = ? LIMIT 1', (region_id,))\n\t\t\tif res:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tres",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tres = run_query_single('SELECT pop_m, pop_f, pop_total FROM population WHERE city_id = ? LIMIT 1', (city_id,))\n\t\t\tif res:\n\t\t\t\treturn res\n\t\tif region_id:\n\t\t\tres = run_query_single('SELECT pop_m, pop_f, pop_total FROM population WHERE region_id = ? LIMIT 1', (region_id,))\n\t\t\tif res:\n\t\t\t\treturn res\n\tfinally:\n\t\ttry:\n\t\t\tif cur:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tres",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tres = run_query_single('SELECT pop_m, pop_f, pop_total FROM population WHERE region_id = ? LIMIT 1', (region_id,))\n\t\t\tif res:\n\t\t\t\treturn res\n\tfinally:\n\t\ttry:\n\t\t\tif cur:\n\t\t\t\tcur.close()\n\t\texcept Exception:\n\t\t\tpass\n\t\ttry:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "ALLOWED_FILES",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "ALLOWED_FILES = {\n\t'geo_regions': os.path.join(os.path.dirname(__file__), 'geojson', 'regions.geojson'),\n\t'geo_districts': os.path.join(os.path.dirname(__file__), 'geojson', 'districts.geojson'),\n\t'geo_cities': os.path.join(os.path.dirname(__file__), 'geojson', 'cities.geojson'),\n}\ndef load_external_file(key):\n\t\"\"\"Load a GeoJSON/JSON file from ALLOWED_FILES by key and cache it in memory.\"\"\"\n\tpath = ALLOWED_FILES.get(key)\n\tif not path or not os.path.isfile(path):\n\t\treturn {'features': []}",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tpath",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tpath = ALLOWED_FILES.get(key)\n\tif not path or not os.path.isfile(path):\n\t\treturn {'features': []}\n\twith open(path, 'r', encoding='utf-8') as fh:\n\t\ttry:\n\t\t\traw = json.load(fh)\n\t\texcept Exception:\n\t\t\treturn {'features': []}\n\t# If the file is a plain list of features\n\tif isinstance(raw, list):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\traw",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\traw = json.load(fh)\n\t\texcept Exception:\n\t\t\treturn {'features': []}\n\t# If the file is a plain list of features\n\tif isinstance(raw, list):\n\t\treturn {'features': raw}\n\t# If it's a dict already with GeoJSON FeatureCollection\n\tif isinstance(raw, dict):\n\t\t# Standard GeoJSON\n\t\tif raw.get('type') == 'FeatureCollection' and isinstance(raw.get('features'), list):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tdata",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tdata = load_external_file(file_key)\n\tneedle = str(neighborhood_value).strip().lower()\n\tif name_field_candidates is None:\n\t\t# include common English and Arabic name fields and variants\n\t\tname_field_candidates = [\n\t\t\t'name', 'NAME', 'Name',\n\t\t\t'name_en', 'NAME_EN', 'EN_NAME', 'nameEn', 'nameEn',\n\t\t\t'name_ar', 'NAME_AR', 'AR_NAME', 'nameAr',\n\t\t\t'region', 'region_id', 'code'\n\t\t]",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tneedle",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tneedle = str(neighborhood_value).strip().lower()\n\tif name_field_candidates is None:\n\t\t# include common English and Arabic name fields and variants\n\t\tname_field_candidates = [\n\t\t\t'name', 'NAME', 'Name',\n\t\t\t'name_en', 'NAME_EN', 'EN_NAME', 'nameEn', 'nameEn',\n\t\t\t'name_ar', 'NAME_AR', 'AR_NAME', 'nameAr',\n\t\t\t'region', 'region_id', 'code'\n\t\t]\n\tfor feat in data.get('features', []):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tname_field_candidates",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tname_field_candidates = [\n\t\t\t'name', 'NAME', 'Name',\n\t\t\t'name_en', 'NAME_EN', 'EN_NAME', 'nameEn', 'nameEn',\n\t\t\t'name_ar', 'NAME_AR', 'AR_NAME', 'nameAr',\n\t\t\t'region', 'region_id', 'code'\n\t\t]\n\tfor feat in data.get('features', []):\n\t\t# features in allowed files may be plain dicts (with properties at top-level)\n\t\tprops = {}\n\t\tif isinstance(feat, dict):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tprops",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tprops = {}\n\t\tif isinstance(feat, dict):\n\t\t\tif 'properties' in feat and isinstance(feat.get('properties'), dict):\n\t\t\t\tprops = feat.get('properties')\n\t\t\telse:\n\t\t\t\t# treat the dict itself as properties (e.g., json/regions.json items)\n\t\t\t\tprops = feat\n\t\tcandidates = []\n\t\tfor k in name_field_candidates:\n\t\t\tv = props.get(k)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tprops",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tprops = feat.get('properties')\n\t\t\telse:\n\t\t\t\t# treat the dict itself as properties (e.g., json/regions.json items)\n\t\t\t\tprops = feat\n\t\tcandidates = []\n\t\tfor k in name_field_candidates:\n\t\t\tv = props.get(k)\n\t\t\tif v:\n\t\t\t\tcandidates.append(str(v).strip().lower())\n\t\tmatched = False",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tprops",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tprops = feat\n\t\tcandidates = []\n\t\tfor k in name_field_candidates:\n\t\t\tv = props.get(k)\n\t\t\tif v:\n\t\t\t\tcandidates.append(str(v).strip().lower())\n\t\tmatched = False\n\t\tfor cand in candidates:\n\t\t\tif cand == needle:\n\t\t\t\tmatched = True",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tcandidates",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tcandidates = []\n\t\tfor k in name_field_candidates:\n\t\t\tv = props.get(k)\n\t\t\tif v:\n\t\t\t\tcandidates.append(str(v).strip().lower())\n\t\tmatched = False\n\t\tfor cand in candidates:\n\t\t\tif cand == needle:\n\t\t\t\tmatched = True\n\t\t\t\tbreak",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tv",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tv = props.get(k)\n\t\t\tif v:\n\t\t\t\tcandidates.append(str(v).strip().lower())\n\t\tmatched = False\n\t\tfor cand in candidates:\n\t\t\tif cand == needle:\n\t\t\t\tmatched = True\n\t\t\t\tbreak\n\t\tif not matched:\n\t\t\tnorm_needle = needle.replace('-', ' ').replace('_', ' ')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tmatched",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tmatched = False\n\t\tfor cand in candidates:\n\t\t\tif cand == needle:\n\t\t\t\tmatched = True\n\t\t\t\tbreak\n\t\tif not matched:\n\t\t\tnorm_needle = needle.replace('-', ' ').replace('_', ' ')\n\t\t\tfor cand in candidates:\n\t\t\t\tif cand.replace('-', ' ').replace('_', ' ') == norm_needle:\n\t\t\t\t\tmatched = True",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tmatched",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tmatched = True\n\t\t\t\tbreak\n\t\tif not matched:\n\t\t\tnorm_needle = needle.replace('-', ' ').replace('_', ' ')\n\t\t\tfor cand in candidates:\n\t\t\t\tif cand.replace('-', ' ').replace('_', ' ') == norm_needle:\n\t\t\t\t\tmatched = True\n\t\t\t\t\tbreak\n\t\tif matched:\n\t\t\treturn feat",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tnorm_needle",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tnorm_needle = needle.replace('-', ' ').replace('_', ' ')\n\t\t\tfor cand in candidates:\n\t\t\t\tif cand.replace('-', ' ').replace('_', ' ') == norm_needle:\n\t\t\t\t\tmatched = True\n\t\t\t\t\tbreak\n\t\tif matched:\n\t\t\treturn feat\n\treturn None\ndef normalize_feature_to_geojson(feat):\n\t\"\"\"Return a GeoJSON Feature dict for various input shapes.",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tmatched",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\tmatched = True\n\t\t\t\t\tbreak\n\t\tif matched:\n\t\t\treturn feat\n\treturn None\ndef normalize_feature_to_geojson(feat):\n\t\"\"\"Return a GeoJSON Feature dict for various input shapes.\n\tConverts files that use `boundaries` (arrays of [lat,lon]) into a\n\tGeoJSON Polygon geometry with coordinates as [lon, lat].\n\t\"\"\"",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tprops",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tprops = feat.get('properties') if isinstance(feat.get('properties'), dict) else {k: v for k, v in feat.items() if k != 'geometry'}\n\t# If there's a geometry object already\n\tif 'geometry' in feat and isinstance(feat['geometry'], dict):\n\t\treturn {'type': 'Feature', 'properties': props, 'geometry': feat['geometry']}\n\t# Common boundary field names that contain ring coordinates\n\tboundary_keys = ['boundaries', 'boundary', 'coordinates', 'coords', 'polygons', 'shape']\n\tfor bk in boundary_keys:\n\t\tif bk in feat and isinstance(feat[bk], list) and feat[bk]:\n\t\t\traw_bound = feat[bk]\n\t\t\t# raw_bound may be a list of rings or a single ring",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tboundary_keys",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tboundary_keys = ['boundaries', 'boundary', 'coordinates', 'coords', 'polygons', 'shape']\n\tfor bk in boundary_keys:\n\t\tif bk in feat and isinstance(feat[bk], list) and feat[bk]:\n\t\t\traw_bound = feat[bk]\n\t\t\t# raw_bound may be a list of rings or a single ring\n\t\t\trings = []\n\t\t\tif isinstance(raw_bound[0], list) and raw_bound and isinstance(raw_bound[0][0], list):\n\t\t\t\t# already a list of rings: [[ [lat,lon], ... ], ...]\n\t\t\t\tfor ring in raw_bound:\n\t\t\t\t\t# convert lat,lon -> lon,lat",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\traw_bound",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\traw_bound = feat[bk]\n\t\t\t# raw_bound may be a list of rings or a single ring\n\t\t\trings = []\n\t\t\tif isinstance(raw_bound[0], list) and raw_bound and isinstance(raw_bound[0][0], list):\n\t\t\t\t# already a list of rings: [[ [lat,lon], ... ], ...]\n\t\t\t\tfor ring in raw_bound:\n\t\t\t\t\t# convert lat,lon -> lon,lat\n\t\t\t\t\tconverted = [[pt[1], pt[0]] for pt in ring]\n\t\t\t\t\trings.append(converted)\n\t\t\telse:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\trings",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\trings = []\n\t\t\tif isinstance(raw_bound[0], list) and raw_bound and isinstance(raw_bound[0][0], list):\n\t\t\t\t# already a list of rings: [[ [lat,lon], ... ], ...]\n\t\t\t\tfor ring in raw_bound:\n\t\t\t\t\t# convert lat,lon -> lon,lat\n\t\t\t\t\tconverted = [[pt[1], pt[0]] for pt in ring]\n\t\t\t\t\trings.append(converted)\n\t\t\telse:\n\t\t\t\t# single ring of points [[lat,lon],...]\n\t\t\t\tconverted = [[pt[1], pt[0]] for pt in raw_bound]",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tconverted",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\tconverted = [[pt[1], pt[0]] for pt in ring]\n\t\t\t\t\trings.append(converted)\n\t\t\telse:\n\t\t\t\t# single ring of points [[lat,lon],...]\n\t\t\t\tconverted = [[pt[1], pt[0]] for pt in raw_bound]\n\t\t\t\trings.append(converted)\n\t\t\tgeometry = {'type': 'Polygon', 'coordinates': rings}\n\t\t\treturn {'type': 'Feature', 'properties': props, 'geometry': geometry}\n\t# If properties contain boundaries (some files store geometry inside properties)\n\tfor bk in boundary_keys:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tconverted",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tconverted = [[pt[1], pt[0]] for pt in raw_bound]\n\t\t\t\trings.append(converted)\n\t\t\tgeometry = {'type': 'Polygon', 'coordinates': rings}\n\t\t\treturn {'type': 'Feature', 'properties': props, 'geometry': geometry}\n\t# If properties contain boundaries (some files store geometry inside properties)\n\tfor bk in boundary_keys:\n\t\tif bk in props and isinstance(props[bk], list) and props[bk]:\n\t\t\traw_bound = props[bk]\n\t\t\trings = []\n\t\t\tif isinstance(raw_bound[0], list) and raw_bound and isinstance(raw_bound[0][0], list):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tgeometry",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tgeometry = {'type': 'Polygon', 'coordinates': rings}\n\t\t\treturn {'type': 'Feature', 'properties': props, 'geometry': geometry}\n\t# If properties contain boundaries (some files store geometry inside properties)\n\tfor bk in boundary_keys:\n\t\tif bk in props and isinstance(props[bk], list) and props[bk]:\n\t\t\traw_bound = props[bk]\n\t\t\trings = []\n\t\t\tif isinstance(raw_bound[0], list) and raw_bound and isinstance(raw_bound[0][0], list):\n\t\t\t\tfor ring in raw_bound:\n\t\t\t\t\tconverted = [[pt[1], pt[0]] for pt in ring]",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\traw_bound",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\traw_bound = props[bk]\n\t\t\trings = []\n\t\t\tif isinstance(raw_bound[0], list) and raw_bound and isinstance(raw_bound[0][0], list):\n\t\t\t\tfor ring in raw_bound:\n\t\t\t\t\tconverted = [[pt[1], pt[0]] for pt in ring]\n\t\t\t\t\trings.append(converted)\n\t\t\telse:\n\t\t\t\tconverted = [[pt[1], pt[0]] for pt in raw_bound]\n\t\t\t\trings.append(converted)\n\t\t\tgeometry = {'type': 'Polygon', 'coordinates': rings}",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\trings",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\trings = []\n\t\t\tif isinstance(raw_bound[0], list) and raw_bound and isinstance(raw_bound[0][0], list):\n\t\t\t\tfor ring in raw_bound:\n\t\t\t\t\tconverted = [[pt[1], pt[0]] for pt in ring]\n\t\t\t\t\trings.append(converted)\n\t\t\telse:\n\t\t\t\tconverted = [[pt[1], pt[0]] for pt in raw_bound]\n\t\t\t\trings.append(converted)\n\t\t\tgeometry = {'type': 'Polygon', 'coordinates': rings}\n\t\t\treturn {'type': 'Feature', 'properties': props, 'geometry': geometry}",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tconverted",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\tconverted = [[pt[1], pt[0]] for pt in ring]\n\t\t\t\t\trings.append(converted)\n\t\t\telse:\n\t\t\t\tconverted = [[pt[1], pt[0]] for pt in raw_bound]\n\t\t\t\trings.append(converted)\n\t\t\tgeometry = {'type': 'Polygon', 'coordinates': rings}\n\t\t\treturn {'type': 'Feature', 'properties': props, 'geometry': geometry}\n\t# As a last resort, wrap dict as feature without geometry\n\treturn {'type': 'Feature', 'properties': props}\ndef _feature_has_polygon(candidate):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tconverted",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tconverted = [[pt[1], pt[0]] for pt in raw_bound]\n\t\t\t\trings.append(converted)\n\t\t\tgeometry = {'type': 'Polygon', 'coordinates': rings}\n\t\t\treturn {'type': 'Feature', 'properties': props, 'geometry': geometry}\n\t# As a last resort, wrap dict as feature without geometry\n\treturn {'type': 'Feature', 'properties': props}\ndef _feature_has_polygon(candidate):\n\t\"\"\"Return True if candidate feature appears to have polygon geometry or boundaries.\"\"\"\n\tif not isinstance(candidate, dict):\n\t\treturn False",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tgeometry",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tgeometry = {'type': 'Polygon', 'coordinates': rings}\n\t\t\treturn {'type': 'Feature', 'properties': props, 'geometry': geometry}\n\t# As a last resort, wrap dict as feature without geometry\n\treturn {'type': 'Feature', 'properties': props}\ndef _feature_has_polygon(candidate):\n\t\"\"\"Return True if candidate feature appears to have polygon geometry or boundaries.\"\"\"\n\tif not isinstance(candidate, dict):\n\t\treturn False\n\t# GeoJSON geometry\n\tgeom = candidate.get('geometry')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tgeom",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tgeom = candidate.get('geometry')\n\tif isinstance(geom, dict):\n\t\tt = geom.get('type')\n\t\tif t in ('Polygon', 'MultiPolygon'):\n\t\t\treturn True\n\t\tif t == 'GeometryCollection' and any(g.get('type') in ('Polygon', 'MultiPolygon') for g in geom.get('geometries', []) if isinstance(g, dict)):\n\t\t\treturn True\n\t# properties may include boundaries/boundary/coordinates\n\tprops = candidate.get('properties') if isinstance(candidate.get('properties'), dict) else candidate\n\tfor bk in ('boundaries', 'boundary', 'polygons', 'shape', 'coordinates'):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tt",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tt = geom.get('type')\n\t\tif t in ('Polygon', 'MultiPolygon'):\n\t\t\treturn True\n\t\tif t == 'GeometryCollection' and any(g.get('type') in ('Polygon', 'MultiPolygon') for g in geom.get('geometries', []) if isinstance(g, dict)):\n\t\t\treturn True\n\t# properties may include boundaries/boundary/coordinates\n\tprops = candidate.get('properties') if isinstance(candidate.get('properties'), dict) else candidate\n\tfor bk in ('boundaries', 'boundary', 'polygons', 'shape', 'coordinates'):\n\t\tif bk in props and isinstance(props[bk], list) and props[bk]:\n\t\t\treturn True",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tprops",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tprops = candidate.get('properties') if isinstance(candidate.get('properties'), dict) else candidate\n\tfor bk in ('boundaries', 'boundary', 'polygons', 'shape', 'coordinates'):\n\t\tif bk in props and isinstance(props[bk], list) and props[bk]:\n\t\t\treturn True\n\treturn False\ndef find_polygon_for_feature(props):\n\t\"\"\"Search allowed files for a feature that matches `props` by id or name and contains polygon geometry.\n\tReturns a GeoJSON feature or None.\n\t\"\"\"\n\tif not isinstance(props, dict):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tid_keys",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tid_keys = ['city_id', 'region_id', 'district_id', 'id', 'region_id']\n\tname_keys = ['name_en', 'name_ar', 'name', 'NAME', 'EN_NAME']\n\t# Collect values to match\n\tids = set()\n\tnames = set()\n\tfor k in id_keys:\n\t\tv = props.get(k)\n\t\tif v is not None:\n\t\t\tids.add(str(v))\n\tfor k in name_keys:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tname_keys",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tname_keys = ['name_en', 'name_ar', 'name', 'NAME', 'EN_NAME']\n\t# Collect values to match\n\tids = set()\n\tnames = set()\n\tfor k in id_keys:\n\t\tv = props.get(k)\n\t\tif v is not None:\n\t\t\tids.add(str(v))\n\tfor k in name_keys:\n\t\tv = props.get(k)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tids",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tids = set()\n\tnames = set()\n\tfor k in id_keys:\n\t\tv = props.get(k)\n\t\tif v is not None:\n\t\t\tids.add(str(v))\n\tfor k in name_keys:\n\t\tv = props.get(k)\n\t\tif v:\n\t\t\tnames.add(str(v).strip().lower())",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tnames",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tnames = set()\n\tfor k in id_keys:\n\t\tv = props.get(k)\n\t\tif v is not None:\n\t\t\tids.add(str(v))\n\tfor k in name_keys:\n\t\tv = props.get(k)\n\t\tif v:\n\t\t\tnames.add(str(v).strip().lower())\n\t# scan files for polygon candidates",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tv",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tv = props.get(k)\n\t\tif v is not None:\n\t\t\tids.add(str(v))\n\tfor k in name_keys:\n\t\tv = props.get(k)\n\t\tif v:\n\t\t\tnames.add(str(v).strip().lower())\n\t# scan files for polygon candidates\n\t# Prefer searching city files first, then districts, then regions, to avoid matching a region polygon when looking for a city\n\tdef _sort_key(k):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tv",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tv = props.get(k)\n\t\tif v:\n\t\t\tnames.add(str(v).strip().lower())\n\t# scan files for polygon candidates\n\t# Prefer searching city files first, then districts, then regions, to avoid matching a region polygon when looking for a city\n\tdef _sort_key(k):\n\t\tk_lower = k.lower()\n\t\tif 'city' in k_lower:\n\t\t\treturn 0\n\t\tif 'district' in k_lower:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tk_lower",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tk_lower = k.lower()\n\t\tif 'city' in k_lower:\n\t\t\treturn 0\n\t\tif 'district' in k_lower:\n\t\t\treturn 1\n\t\tif 'region' in k_lower:\n\t\t\treturn 2\n\t\treturn 3\n\tfor key in sorted(ALLOWED_FILES.keys(), key=_sort_key):\n\t\tdata = load_external_file(key)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tdata",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tdata = load_external_file(key)\n\t\tfor cand in data.get('features', []):\n\t\t\tcprops = cand.get('properties') if isinstance(cand, dict) and 'properties' in cand else cand\n\t\t\t# check id match\n\t\t\tmatched = False\n\t\t\tfor k in id_keys:\n\t\t\t\tcv = cprops.get(k)\n\t\t\t\tif cv is not None and str(cv) in ids:\n\t\t\t\t\tmatched = True\n\t\t\t\t\tbreak",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tcprops",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tcprops = cand.get('properties') if isinstance(cand, dict) and 'properties' in cand else cand\n\t\t\t# check id match\n\t\t\tmatched = False\n\t\t\tfor k in id_keys:\n\t\t\t\tcv = cprops.get(k)\n\t\t\t\tif cv is not None and str(cv) in ids:\n\t\t\t\t\tmatched = True\n\t\t\t\t\tbreak\n\t\t\tif not matched:\n\t\t\t\t# check name match",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tmatched",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tmatched = False\n\t\t\tfor k in id_keys:\n\t\t\t\tcv = cprops.get(k)\n\t\t\t\tif cv is not None and str(cv) in ids:\n\t\t\t\t\tmatched = True\n\t\t\t\t\tbreak\n\t\t\tif not matched:\n\t\t\t\t# check name match\n\t\t\t\tfor nk in name_keys:\n\t\t\t\t\tcv = cprops.get(nk)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tcv",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tcv = cprops.get(k)\n\t\t\t\tif cv is not None and str(cv) in ids:\n\t\t\t\t\tmatched = True\n\t\t\t\t\tbreak\n\t\t\tif not matched:\n\t\t\t\t# check name match\n\t\t\t\tfor nk in name_keys:\n\t\t\t\t\tcv = cprops.get(nk)\n\t\t\t\t\tif cv and str(cv).strip().lower() in names:\n\t\t\t\t\t\tmatched = True",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tmatched",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\tmatched = True\n\t\t\t\t\tbreak\n\t\t\tif not matched:\n\t\t\t\t# check name match\n\t\t\t\tfor nk in name_keys:\n\t\t\t\t\tcv = cprops.get(nk)\n\t\t\t\t\tif cv and str(cv).strip().lower() in names:\n\t\t\t\t\t\tmatched = True\n\t\t\t\t\t\tbreak\n\t\t\tif not matched:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tcv",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\tcv = cprops.get(nk)\n\t\t\t\t\tif cv and str(cv).strip().lower() in names:\n\t\t\t\t\t\tmatched = True\n\t\t\t\t\t\tbreak\n\t\t\tif not matched:\n\t\t\t\tcontinue\n\t\t\t# if this candidate has polygon-like geometry, normalize and return\n\t\t\tif _feature_has_polygon(cand):\n\t\t\t\treturn normalize_feature_to_geojson(cand)\n\treturn None",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\tmatched",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\t\tmatched = True\n\t\t\t\t\t\tbreak\n\t\t\tif not matched:\n\t\t\t\tcontinue\n\t\t\t# if this candidate has polygon-like geometry, normalize and return\n\t\t\tif _feature_has_polygon(cand):\n\t\t\t\treturn normalize_feature_to_geojson(cand)\n\treturn None\n@app.route('/stats_city')\ndef stats_city():",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tcity_id",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tcity_id = request.args.get('city_id')\n\tcity_name = request.args.get('city_name')\n\t# Optional region context to disambiguate cities with same name\n\tregion_id = request.args.get('region_id')\n\tregion_name = request.args.get('region_name')\n\t# Normalize city_name: some UI display strings include an English suffix like\n\t# \"  Al Shurta\" or \"Name  EN\". Prefer the left-side (Arabic) part\n\t# for matching. Also trim whitespace.\n\tif city_name and isinstance(city_name, str):\n\t\t# common separators used in our UI display",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tcity_name",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tcity_name = request.args.get('city_name')\n\t# Optional region context to disambiguate cities with same name\n\tregion_id = request.args.get('region_id')\n\tregion_name = request.args.get('region_name')\n\t# Normalize city_name: some UI display strings include an English suffix like\n\t# \"  Al Shurta\" or \"Name  EN\". Prefer the left-side (Arabic) part\n\t# for matching. Also trim whitespace.\n\tif city_name and isinstance(city_name, str):\n\t\t# common separators used in our UI display\n\t\tfor sep in ('  ', ' - ', '  ', '', ''):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tregion_id",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tregion_id = request.args.get('region_id')\n\tregion_name = request.args.get('region_name')\n\t# Normalize city_name: some UI display strings include an English suffix like\n\t# \"  Al Shurta\" or \"Name  EN\". Prefer the left-side (Arabic) part\n\t# for matching. Also trim whitespace.\n\tif city_name and isinstance(city_name, str):\n\t\t# common separators used in our UI display\n\t\tfor sep in ('  ', ' - ', '  ', '', ''):\n\t\t\tif sep in city_name:\n\t\t\t\tcity_name = city_name.split(sep, 1)[0].strip()",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tregion_name",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tregion_name = request.args.get('region_name')\n\t# Normalize city_name: some UI display strings include an English suffix like\n\t# \"  Al Shurta\" or \"Name  EN\". Prefer the left-side (Arabic) part\n\t# for matching. Also trim whitespace.\n\tif city_name and isinstance(city_name, str):\n\t\t# common separators used in our UI display\n\t\tfor sep in ('  ', ' - ', '  ', '', ''):\n\t\t\tif sep in city_name:\n\t\t\t\tcity_name = city_name.split(sep, 1)[0].strip()\n\t\t\t\tbreak",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tcity_name",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tcity_name = city_name.split(sep, 1)[0].strip()\n\t\t\t\tbreak\n\t# Try city files first (but don't fail if none are configured; we'll fallback to searching all files)\n\tcity_keys = [k for k in ALLOWED_FILES.keys() if 'city' in k]\n\t# helper to search a list of keys\n\tdef _search_keys(keys):\n\t\tfor key in keys:\n\t\t\tdata = load_external_file(key)\n\t\t\tfor feat in data.get('features', []):\n\t\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tcity_keys",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tcity_keys = [k for k in ALLOWED_FILES.keys() if 'city' in k]\n\t# helper to search a list of keys\n\tdef _search_keys(keys):\n\t\tfor key in keys:\n\t\t\tdata = load_external_file(key)\n\t\t\tfor feat in data.get('features', []):\n\t\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat\n\t\t\t\tif city_id:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tif str(props.get('city_id') or props.get('id') or '') == str(city_id):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tdata",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tdata = load_external_file(key)\n\t\t\tfor feat in data.get('features', []):\n\t\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat\n\t\t\t\tif city_id:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tif str(props.get('city_id') or props.get('id') or '') == str(city_id):\n\t\t\t\t\t\t\t# respect region scoping if provided\n\t\t\t\t\t\t\tif region_id and str(props.get('region_id') or '') != str(region_id):\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\tif region_name and any(str(props.get(k,'')).strip().lower() == str(region_name).strip().lower() for k in ('region','region_name','name','NAME','name_en','name_ar')):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tprops",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat\n\t\t\t\tif city_id:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tif str(props.get('city_id') or props.get('id') or '') == str(city_id):\n\t\t\t\t\t\t\t# respect region scoping if provided\n\t\t\t\t\t\t\tif region_id and str(props.get('region_id') or '') != str(region_id):\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\tif region_name and any(str(props.get(k,'')).strip().lower() == str(region_name).strip().lower() for k in ('region','region_name','name','NAME','name_en','name_ar')):\n\t\t\t\t\t\t\t\t# ok if region name matches\n\t\t\t\t\t\t\t\tpass",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\tv",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\t\tv = props.get(namek)\n\t\t\t\t\t\tif v and str(v).strip().lower() == str(city_name).strip().lower():\n\t\t\t\t\t\t\t# check region scoping\n\t\t\t\t\t\t\tif region_id and str(props.get('region_id') or '') != str(region_id):\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\tif region_name:\n\t\t\t\t\t\t\t\t# if props contains region fields, require match\n\t\t\t\t\t\t\t\tif any(k in props for k in ('region','region_name','region_id')):\n\t\t\t\t\t\t\t\t\tif not any(str(props.get(k,'')).strip().lower() == str(region_name).strip().lower() for k in ('region','region_name','name','NAME','name_en','name_ar')):\n\t\t\t\t\t\t\t\t\t\tcontinue",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tneedle",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tneedle = city_name or city_id\n\t\tpotential = (None, None, None)\n\t\tfound = (None, None, None)\n\t\tname_keys = ('name_en','name_ar','name','NAME')\n\t\tfor k in ALLOWED_FILES.keys():\n\t\t\tdata = load_external_file(k)\n\t\t\tfor cand in data.get('features', []):\n\t\t\t\tcprops = cand.get('properties') if isinstance(cand, dict) and 'properties' in cand else cand\n\t\t\t\t# id match\n\t\t\t\ttry:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tpotential",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tpotential = (None, None, None)\n\t\tfound = (None, None, None)\n\t\tname_keys = ('name_en','name_ar','name','NAME')\n\t\tfor k in ALLOWED_FILES.keys():\n\t\t\tdata = load_external_file(k)\n\t\t\tfor cand in data.get('features', []):\n\t\t\t\tcprops = cand.get('properties') if isinstance(cand, dict) and 'properties' in cand else cand\n\t\t\t\t# id match\n\t\t\t\ttry:\n\t\t\t\t\tif city_id and str(cprops.get('city_id') or cprops.get('id') or '') == str(city_id):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tfound",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tfound = (None, None, None)\n\t\tname_keys = ('name_en','name_ar','name','NAME')\n\t\tfor k in ALLOWED_FILES.keys():\n\t\t\tdata = load_external_file(k)\n\t\t\tfor cand in data.get('features', []):\n\t\t\t\tcprops = cand.get('properties') if isinstance(cand, dict) and 'properties' in cand else cand\n\t\t\t\t# id match\n\t\t\t\ttry:\n\t\t\t\t\tif city_id and str(cprops.get('city_id') or cprops.get('id') or '') == str(city_id):\n\t\t\t\t\t\t# respect region scoping if provided",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tname_keys",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tname_keys = ('name_en','name_ar','name','NAME')\n\t\tfor k in ALLOWED_FILES.keys():\n\t\t\tdata = load_external_file(k)\n\t\t\tfor cand in data.get('features', []):\n\t\t\t\tcprops = cand.get('properties') if isinstance(cand, dict) and 'properties' in cand else cand\n\t\t\t\t# id match\n\t\t\t\ttry:\n\t\t\t\t\tif city_id and str(cprops.get('city_id') or cprops.get('id') or '') == str(city_id):\n\t\t\t\t\t\t# respect region scoping if provided\n\t\t\t\t\t\tif region_id and str(cprops.get('region_id') or '') != str(region_id):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tdata",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tdata = load_external_file(k)\n\t\t\tfor cand in data.get('features', []):\n\t\t\t\tcprops = cand.get('properties') if isinstance(cand, dict) and 'properties' in cand else cand\n\t\t\t\t# id match\n\t\t\t\ttry:\n\t\t\t\t\tif city_id and str(cprops.get('city_id') or cprops.get('id') or '') == str(city_id):\n\t\t\t\t\t\t# respect region scoping if provided\n\t\t\t\t\t\tif region_id and str(cprops.get('region_id') or '') != str(region_id):\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t# prefer city-level records: skip district records (they also carry city_id)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tcprops",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tcprops = cand.get('properties') if isinstance(cand, dict) and 'properties' in cand else cand\n\t\t\t\t# id match\n\t\t\t\ttry:\n\t\t\t\t\tif city_id and str(cprops.get('city_id') or cprops.get('id') or '') == str(city_id):\n\t\t\t\t\t\t# respect region scoping if provided\n\t\t\t\t\t\tif region_id and str(cprops.get('region_id') or '') != str(region_id):\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t# prefer city-level records: skip district records (they also carry city_id)\n\t\t\t\t\t\tif 'district_id' in cprops:\n\t\t\t\t\t\t\t# treat as potential match but don't prefer it",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\t\t\tpotential",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\t\t\t\tpotential = (k, cand, cprops)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tfound = (k, cand, cprops)\n\t\t\t\t\t\tbreak\n\t\t\t\texcept Exception:\n\t\t\t\t\tpass\n\t\t\t\t# name match\n\t\t\t\tif city_name:\n\t\t\t\t\tdn = str(city_name).strip().lower()\n\t\t\t\t\tmatched = False",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\tfound",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\t\tfound = (k, cand, cprops)\n\t\t\t\t\t\tbreak\n\t\t\t\texcept Exception:\n\t\t\t\t\tpass\n\t\t\t\t# name match\n\t\t\t\tif city_name:\n\t\t\t\t\tdn = str(city_name).strip().lower()\n\t\t\t\t\tmatched = False\n\t\t\t\t\tfor nk in name_keys:\n\t\t\t\t\t\tv = cprops.get(nk)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tdn",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\tdn = str(city_name).strip().lower()\n\t\t\t\t\tmatched = False\n\t\t\t\t\tfor nk in name_keys:\n\t\t\t\t\t\tv = cprops.get(nk)\n\t\t\t\t\t\tif v and str(v).strip().lower() == dn:\n\t\t\t\t\t\t\tmatched = True\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\tif not matched:\n\t\t\t\t\t\tfor nk in name_keys:\n\t\t\t\t\t\t\tv = cprops.get(nk)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tmatched",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\tmatched = False\n\t\t\t\t\tfor nk in name_keys:\n\t\t\t\t\t\tv = cprops.get(nk)\n\t\t\t\t\t\tif v and str(v).strip().lower() == dn:\n\t\t\t\t\t\t\tmatched = True\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\tif not matched:\n\t\t\t\t\t\tfor nk in name_keys:\n\t\t\t\t\t\t\tv = cprops.get(nk)\n\t\t\t\t\t\t\tif v and str(v).strip().lower().replace('-', ' ').replace('_',' ') == dn.replace('-', ' ').replace('_',' '):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\tv",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\t\tv = cprops.get(nk)\n\t\t\t\t\t\tif v and str(v).strip().lower() == dn:\n\t\t\t\t\t\t\tmatched = True\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\tif not matched:\n\t\t\t\t\t\tfor nk in name_keys:\n\t\t\t\t\t\t\tv = cprops.get(nk)\n\t\t\t\t\t\t\tif v and str(v).strip().lower().replace('-', ' ').replace('_',' ') == dn.replace('-', ' ').replace('_',' '):\n\t\t\t\t\t\t\t\tmatched = True\n\t\t\t\t\t\t\t\tbreak",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\t\tmatched",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\t\t\tmatched = True\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\tif not matched:\n\t\t\t\t\t\tfor nk in name_keys:\n\t\t\t\t\t\t\tv = cprops.get(nk)\n\t\t\t\t\t\t\tif v and str(v).strip().lower().replace('-', ' ').replace('_',' ') == dn.replace('-', ' ').replace('_',' '):\n\t\t\t\t\t\t\t\tmatched = True\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\tif matched:\n\t\t\t\t\t\t# require region match if provided",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\t\tv",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\t\t\tv = cprops.get(nk)\n\t\t\t\t\t\t\tif v and str(v).strip().lower().replace('-', ' ').replace('_',' ') == dn.replace('-', ' ').replace('_',' '):\n\t\t\t\t\t\t\t\tmatched = True\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\tif matched:\n\t\t\t\t\t\t# require region match if provided\n\t\t\t\t\t\tif region_id and str(cprops.get('region_id') or '') != str(region_id):\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t# skip district-level features as preferred (they often contain city_id)\n\t\t\t\t\t\tif 'district_id' in cprops:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\t\t\tmatched",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\t\t\t\tmatched = True\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\tif matched:\n\t\t\t\t\t\t# require region match if provided\n\t\t\t\t\t\tif region_id and str(cprops.get('region_id') or '') != str(region_id):\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t# skip district-level features as preferred (they often contain city_id)\n\t\t\t\t\t\tif 'district_id' in cprops:\n\t\t\t\t\t\t\tif potential[0] is None:\n\t\t\t\t\t\t\t\tpotential = (k, cand, cprops)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\t\t\tpotential",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\t\t\t\tpotential = (k, cand, cprops)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t# prefer candidates that include a city_id or are from city files\n\t\t\t\t\t\tif 'city_id' in cprops or 'city' in k:\n\t\t\t\t\t\t\tfound = (k, cand, cprops)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t# otherwise keep as potential if we don't yet have one\n\t\t\t\t\t\tif potential[0] is None:\n\t\t\t\t\t\t\tpotential = (k, cand, cprops)\n\t\t\tif found[0] is not None:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\t\tfound",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\t\t\tfound = (k, cand, cprops)\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t# otherwise keep as potential if we don't yet have one\n\t\t\t\t\t\tif potential[0] is None:\n\t\t\t\t\t\t\tpotential = (k, cand, cprops)\n\t\t\tif found[0] is not None:\n\t\t\t\tbreak\n\t\tif found[0] is not None:\n\t\t\tkey, feat, props = found\n\t\t\tapp.logger.info('stats_city fallback found (preferred) in %s with props id=%s name_en=%s name_ar=%s', key, props.get('city_id') or props.get('id'), props.get('name_en'), props.get('name_ar'))",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\t\tpotential",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\t\t\tpotential = (k, cand, cprops)\n\t\t\tif found[0] is not None:\n\t\t\t\tbreak\n\t\tif found[0] is not None:\n\t\t\tkey, feat, props = found\n\t\t\tapp.logger.info('stats_city fallback found (preferred) in %s with props id=%s name_en=%s name_ar=%s', key, props.get('city_id') or props.get('id'), props.get('name_en'), props.get('name_ar'))\n\t\telif potential[0] is not None:\n\t\t\tkey, feat, props = potential\n\t\t\tapp.logger.info('stats_city fallback found (potential) in %s with props id=%s name_en=%s name_ar=%s', key, props.get('city_id') or props.get('id'), props.get('name_en'), props.get('name_ar'))\n\tif not feat:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tgf",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tgf = normalize_feature_to_geojson(feat)\n\t# If there's no geometry but the record has a `center` coordinate, convert it to a Point geometry.\n\t# Many of our JSON city records store `center` as [lat, lon]; normalize to GeoJSON [lon, lat].\n\t# NOTE: Do NOT attempt an automatic search for a polygon elsewhere when a city is a point-only\n\t# (this caused villages or point-only cities to be replaced with unrelated region/district polygons).\n\tif gf and (not gf.get('geometry') or not isinstance(gf.get('geometry'), dict)):\n\t\tcenter = None\n\t\t# props may be in gf['properties'] or already in props\n\t\tp = gf.get('properties') or props\n\t\tif isinstance(p, dict) and p.get('center') and isinstance(p.get('center'), (list, tuple)) and len(p.get('center')) >= 2:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tcenter",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tcenter = None\n\t\t# props may be in gf['properties'] or already in props\n\t\tp = gf.get('properties') or props\n\t\tif isinstance(p, dict) and p.get('center') and isinstance(p.get('center'), (list, tuple)) and len(p.get('center')) >= 2:\n\t\t\tcenter = p.get('center')\n\t\t# also check for 'lon'/'lat' fields\n\t\tif not center and isinstance(p, dict) and ('latitude' in p and 'longitude' in p):\n\t\t\tcenter = [p.get('latitude'), p.get('longitude')]\n\t\tif center:\n\t\t\ttry:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tp",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tp = gf.get('properties') or props\n\t\tif isinstance(p, dict) and p.get('center') and isinstance(p.get('center'), (list, tuple)) and len(p.get('center')) >= 2:\n\t\t\tcenter = p.get('center')\n\t\t# also check for 'lon'/'lat' fields\n\t\tif not center and isinstance(p, dict) and ('latitude' in p and 'longitude' in p):\n\t\t\tcenter = [p.get('latitude'), p.get('longitude')]\n\t\tif center:\n\t\t\ttry:\n\t\t\t\tlat = float(center[0])\n\t\t\t\tlon = float(center[1])",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tcenter",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tcenter = p.get('center')\n\t\t# also check for 'lon'/'lat' fields\n\t\tif not center and isinstance(p, dict) and ('latitude' in p and 'longitude' in p):\n\t\t\tcenter = [p.get('latitude'), p.get('longitude')]\n\t\tif center:\n\t\t\ttry:\n\t\t\t\tlat = float(center[0])\n\t\t\t\tlon = float(center[1])\n\t\t\t\tgf['geometry'] = {'type': 'Point', 'coordinates': [lon, lat]}\n\t\t\texcept Exception:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tcenter",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tcenter = [p.get('latitude'), p.get('longitude')]\n\t\tif center:\n\t\t\ttry:\n\t\t\t\tlat = float(center[0])\n\t\t\t\tlon = float(center[1])\n\t\t\t\tgf['geometry'] = {'type': 'Point', 'coordinates': [lon, lat]}\n\t\t\texcept Exception:\n\t\t\t\tpass\n\t# Do NOT attempt to find/replace the point with another polygon here. If a polygon exists\n\t# for the city it should be present in the matched record; otherwise we keep the Point.",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tlat",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tlat = float(center[0])\n\t\t\t\tlon = float(center[1])\n\t\t\t\tgf['geometry'] = {'type': 'Point', 'coordinates': [lon, lat]}\n\t\t\texcept Exception:\n\t\t\t\tpass\n\t# Do NOT attempt to find/replace the point with another polygon here. If a polygon exists\n\t# for the city it should be present in the matched record; otherwise we keep the Point.\n\tapp.logger.info('stats_city returning file_key=%s neighborhood=%s props=%s', key, props.get('name_en') or props.get('name_ar') or city_name or city_id, {k: props.get(k) for k in ('city_id','region_id','name_en','name_ar')})\n\tresponse = {'file_key': key, 'neighborhood': props.get('name_en') or props.get('name_ar') or city_name or city_id, 'feature': gf, 'properties': props}\n\treturn jsonify(response)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tlon",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tlon = float(center[1])\n\t\t\t\tgf['geometry'] = {'type': 'Point', 'coordinates': [lon, lat]}\n\t\t\texcept Exception:\n\t\t\t\tpass\n\t# Do NOT attempt to find/replace the point with another polygon here. If a polygon exists\n\t# for the city it should be present in the matched record; otherwise we keep the Point.\n\tapp.logger.info('stats_city returning file_key=%s neighborhood=%s props=%s', key, props.get('name_en') or props.get('name_ar') or city_name or city_id, {k: props.get(k) for k in ('city_id','region_id','name_en','name_ar')})\n\tresponse = {'file_key': key, 'neighborhood': props.get('name_en') or props.get('name_ar') or city_name or city_id, 'feature': gf, 'properties': props}\n\treturn jsonify(response)\n@app.route('/stats_district')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tgf['geometry']",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tgf['geometry'] = {'type': 'Point', 'coordinates': [lon, lat]}\n\t\t\texcept Exception:\n\t\t\t\tpass\n\t# Do NOT attempt to find/replace the point with another polygon here. If a polygon exists\n\t# for the city it should be present in the matched record; otherwise we keep the Point.\n\tapp.logger.info('stats_city returning file_key=%s neighborhood=%s props=%s', key, props.get('name_en') or props.get('name_ar') or city_name or city_id, {k: props.get(k) for k in ('city_id','region_id','name_en','name_ar')})\n\tresponse = {'file_key': key, 'neighborhood': props.get('name_en') or props.get('name_ar') or city_name or city_id, 'feature': gf, 'properties': props}\n\treturn jsonify(response)\n@app.route('/stats_district')\ndef stats_district():",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tresponse",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tresponse = {'file_key': key, 'neighborhood': props.get('name_en') or props.get('name_ar') or city_name or city_id, 'feature': gf, 'properties': props}\n\treturn jsonify(response)\n@app.route('/stats_district')\ndef stats_district():\n\t\"\"\"Return a district feature by `district_id`/`district_name` optionally scoped to a city (`city_id` or `city_name`).\"\"\"\n\tdistrict_id = request.args.get('district_id')\n\tdistrict_name = request.args.get('district_name')\n\tcity_id = request.args.get('city_id')\n\tcity_name = request.args.get('city_name')\n\tif not district_id and not district_name:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tdistrict_id",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tdistrict_id = request.args.get('district_id')\n\tdistrict_name = request.args.get('district_name')\n\tcity_id = request.args.get('city_id')\n\tcity_name = request.args.get('city_name')\n\tif not district_id and not district_name:\n\t\treturn jsonify({'error': 'missing district identifier'}), 400\n\t# prefer district files first\n\tdistrict_keys = [k for k in ALLOWED_FILES.keys() if 'district' in k]\n\tdef _search_in_keys(keys):\n\t\tfor key in keys:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tdistrict_name",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tdistrict_name = request.args.get('district_name')\n\tcity_id = request.args.get('city_id')\n\tcity_name = request.args.get('city_name')\n\tif not district_id and not district_name:\n\t\treturn jsonify({'error': 'missing district identifier'}), 400\n\t# prefer district files first\n\tdistrict_keys = [k for k in ALLOWED_FILES.keys() if 'district' in k]\n\tdef _search_in_keys(keys):\n\t\tfor key in keys:\n\t\t\tdata = load_external_file(key)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tcity_id",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tcity_id = request.args.get('city_id')\n\tcity_name = request.args.get('city_name')\n\tif not district_id and not district_name:\n\t\treturn jsonify({'error': 'missing district identifier'}), 400\n\t# prefer district files first\n\tdistrict_keys = [k for k in ALLOWED_FILES.keys() if 'district' in k]\n\tdef _search_in_keys(keys):\n\t\tfor key in keys:\n\t\t\tdata = load_external_file(key)\n\t\t\tfor feat in data.get('features', []):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tcity_name",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tcity_name = request.args.get('city_name')\n\tif not district_id and not district_name:\n\t\treturn jsonify({'error': 'missing district identifier'}), 400\n\t# prefer district files first\n\tdistrict_keys = [k for k in ALLOWED_FILES.keys() if 'district' in k]\n\tdef _search_in_keys(keys):\n\t\tfor key in keys:\n\t\t\tdata = load_external_file(key)\n\t\t\tfor feat in data.get('features', []):\n\t\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tdistrict_keys",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tdistrict_keys = [k for k in ALLOWED_FILES.keys() if 'district' in k]\n\tdef _search_in_keys(keys):\n\t\tfor key in keys:\n\t\t\tdata = load_external_file(key)\n\t\t\tfor feat in data.get('features', []):\n\t\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat\n\t\t\t\tif district_id:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tif str(props.get('district_id') or props.get('id') or '') == str(district_id):\n\t\t\t\t\t\t\t# if city context provided, ensure match",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tdata",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tdata = load_external_file(key)\n\t\t\tfor feat in data.get('features', []):\n\t\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat\n\t\t\t\tif district_id:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tif str(props.get('district_id') or props.get('id') or '') == str(district_id):\n\t\t\t\t\t\t\t# if city context provided, ensure match\n\t\t\t\t\t\t\tif city_id and str(props.get('city_id') or '') != str(city_id):\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\tif city_name:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tprops",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat\n\t\t\t\tif district_id:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tif str(props.get('district_id') or props.get('id') or '') == str(district_id):\n\t\t\t\t\t\t\t# if city context provided, ensure match\n\t\t\t\t\t\t\tif city_id and str(props.get('city_id') or '') != str(city_id):\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\tif city_name:\n\t\t\t\t\t\t\t\t# compare city name fields if available\n\t\t\t\t\t\t\t\tif not any(str(props.get(k,'')).strip().lower() == str(city_name).strip().lower() for k in ('city_name','name','NAME','name_en','name_ar')):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tdn",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\tdn = str(district_name).strip().lower()\n\t\t\t\t\tmatched = False\n\t\t\t\t\tfor nk in ('name_en','name_ar','name','NAME'):\n\t\t\t\t\t\tv = props.get(nk)\n\t\t\t\t\t\tif v and str(v).strip().lower() == dn:\n\t\t\t\t\t\t\tmatched = True\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\tif not matched:\n\t\t\t\t\t\t# loosened normalization\n\t\t\t\t\t\tfor nk in ('name_en','name_ar','name','NAME'):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tmatched",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\tmatched = False\n\t\t\t\t\tfor nk in ('name_en','name_ar','name','NAME'):\n\t\t\t\t\t\tv = props.get(nk)\n\t\t\t\t\t\tif v and str(v).strip().lower() == dn:\n\t\t\t\t\t\t\tmatched = True\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\tif not matched:\n\t\t\t\t\t\t# loosened normalization\n\t\t\t\t\t\tfor nk in ('name_en','name_ar','name','NAME'):\n\t\t\t\t\t\t\tv = props.get(nk)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\tv",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\t\tv = props.get(nk)\n\t\t\t\t\t\tif v and str(v).strip().lower() == dn:\n\t\t\t\t\t\t\tmatched = True\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\tif not matched:\n\t\t\t\t\t\t# loosened normalization\n\t\t\t\t\t\tfor nk in ('name_en','name_ar','name','NAME'):\n\t\t\t\t\t\t\tv = props.get(nk)\n\t\t\t\t\t\t\tif v and str(v).strip().lower().replace('-', ' ').replace('_',' ') == dn.replace('-', ' ').replace('_',' '):\n\t\t\t\t\t\t\t\tmatched = True",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\t\tmatched",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\t\t\tmatched = True\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\tif not matched:\n\t\t\t\t\t\t# loosened normalization\n\t\t\t\t\t\tfor nk in ('name_en','name_ar','name','NAME'):\n\t\t\t\t\t\t\tv = props.get(nk)\n\t\t\t\t\t\t\tif v and str(v).strip().lower().replace('-', ' ').replace('_',' ') == dn.replace('-', ' ').replace('_',' '):\n\t\t\t\t\t\t\t\tmatched = True\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\tif matched:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\t\tv",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\t\t\tv = props.get(nk)\n\t\t\t\t\t\t\tif v and str(v).strip().lower().replace('-', ' ').replace('_',' ') == dn.replace('-', ' ').replace('_',' '):\n\t\t\t\t\t\t\t\tmatched = True\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\tif matched:\n\t\t\t\t\t\t# check city scoping if provided\n\t\t\t\t\t\tif city_id and str(props.get('city_id') or '') != str(city_id):\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tif city_name:\n\t\t\t\t\t\t\t# if props contains city_name fields, require match",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\t\t\tmatched",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\t\t\t\tmatched = True\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\tif matched:\n\t\t\t\t\t\t# check city scoping if provided\n\t\t\t\t\t\tif city_id and str(props.get('city_id') or '') != str(city_id):\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tif city_name:\n\t\t\t\t\t\t\t# if props contains city_name fields, require match\n\t\t\t\t\t\t\tif any(k in props for k in ('city_name','city','region')):\n\t\t\t\t\t\t\t\tif not any(str(props.get(k,'')).strip().lower() == str(city_name).strip().lower() for k in ('city_name','city','region','name_en','name_ar')):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tprops",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat\n\tif not feat:\n\t\treturn jsonify({'error': 'district not found'}), 404\n\tgf = normalize_feature_to_geojson(feat)\n\t# if point, try find polygon for district\n\tif gf and gf.get('geometry') and gf.get('geometry').get('type') == 'Point':\n\t\tpoly = find_polygon_for_feature(props)\n\t\tif poly:\n\t\t\tgf = poly\n\tresponse = {'file_key': key, 'neighborhood': props.get('name_en') or props.get('name_ar') or district_name or district_id, 'feature': gf, 'properties': props}",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tgf",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tgf = normalize_feature_to_geojson(feat)\n\t# if point, try find polygon for district\n\tif gf and gf.get('geometry') and gf.get('geometry').get('type') == 'Point':\n\t\tpoly = find_polygon_for_feature(props)\n\t\tif poly:\n\t\t\tgf = poly\n\tresponse = {'file_key': key, 'neighborhood': props.get('name_en') or props.get('name_ar') or district_name or district_id, 'feature': gf, 'properties': props}\n\treturn jsonify(response)\n@app.route('/stats_region')\ndef stats_region():",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tpoly",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tpoly = find_polygon_for_feature(props)\n\t\tif poly:\n\t\t\tgf = poly\n\tresponse = {'file_key': key, 'neighborhood': props.get('name_en') or props.get('name_ar') or district_name or district_id, 'feature': gf, 'properties': props}\n\treturn jsonify(response)\n@app.route('/stats_region')\ndef stats_region():\n\t\"\"\"Return a region feature (prefer polygon) by `region_id` or `region_name`.\n\tQuery params:\n\t- region_id (optional)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tgf",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tgf = poly\n\tresponse = {'file_key': key, 'neighborhood': props.get('name_en') or props.get('name_ar') or district_name or district_id, 'feature': gf, 'properties': props}\n\treturn jsonify(response)\n@app.route('/stats_region')\ndef stats_region():\n\t\"\"\"Return a region feature (prefer polygon) by `region_id` or `region_name`.\n\tQuery params:\n\t- region_id (optional)\n\t- region_name (optional)\n\t\"\"\"",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tresponse",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tresponse = {'file_key': key, 'neighborhood': props.get('name_en') or props.get('name_ar') or district_name or district_id, 'feature': gf, 'properties': props}\n\treturn jsonify(response)\n@app.route('/stats_region')\ndef stats_region():\n\t\"\"\"Return a region feature (prefer polygon) by `region_id` or `region_name`.\n\tQuery params:\n\t- region_id (optional)\n\t- region_name (optional)\n\t\"\"\"\n\tregion_id = request.args.get('region_id')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tregion_id",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tregion_id = request.args.get('region_id')\n\tregion_name = request.args.get('region_name')\n\t# Try region-specific files first\n\tregion_keys = [k for k in ALLOWED_FILES.keys() if 'region' in k]\n\tdef _search_keys(keys):\n\t\tfor key in keys:\n\t\t\tdata = load_external_file(key)\n\t\t\tfor feat in data.get('features', []):\n\t\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat\n\t\t\t\tif region_id:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tregion_name",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tregion_name = request.args.get('region_name')\n\t# Try region-specific files first\n\tregion_keys = [k for k in ALLOWED_FILES.keys() if 'region' in k]\n\tdef _search_keys(keys):\n\t\tfor key in keys:\n\t\t\tdata = load_external_file(key)\n\t\t\tfor feat in data.get('features', []):\n\t\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat\n\t\t\t\tif region_id:\n\t\t\t\t\ttry:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tregion_keys",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tregion_keys = [k for k in ALLOWED_FILES.keys() if 'region' in k]\n\tdef _search_keys(keys):\n\t\tfor key in keys:\n\t\t\tdata = load_external_file(key)\n\t\t\tfor feat in data.get('features', []):\n\t\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat\n\t\t\t\tif region_id:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tif str(props.get('region_id') or props.get('id') or '') == str(region_id):\n\t\t\t\t\t\t\treturn key, feat, props",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tdata",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tdata = load_external_file(key)\n\t\t\tfor feat in data.get('features', []):\n\t\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat\n\t\t\t\tif region_id:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tif str(props.get('region_id') or props.get('id') or '') == str(region_id):\n\t\t\t\t\t\t\treturn key, feat, props\n\t\t\t\t\texcept Exception:\n\t\t\t\t\t\tpass\n\t\t\t\tif region_name:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tprops",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat\n\t\t\t\tif region_id:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tif str(props.get('region_id') or props.get('id') or '') == str(region_id):\n\t\t\t\t\t\t\treturn key, feat, props\n\t\t\t\t\texcept Exception:\n\t\t\t\t\t\tpass\n\t\t\t\tif region_name:\n\t\t\t\t\tfor namek in ('name_en','name_ar','name','NAME'):\n\t\t\t\t\t\tv = props.get(namek)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\tv",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\t\tv = props.get(namek)\n\t\t\t\t\t\tif v and str(v).strip().lower() == str(region_name).strip().lower():\n\t\t\t\t\t\t\treturn key, feat, props\n\t\treturn None, None, None\n\tkey, feat, props = _search_keys(region_keys)\n\t# fallback: search all files\n\tif not feat:\n\t\tkey, feat = query_all_files(region_name or region_id, None)\n\t\tif feat:\n\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tprops",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat\n\tif not feat:\n\t\treturn jsonify({'error': 'region not found'}), 404\n\tgf = normalize_feature_to_geojson(feat)\n\t# If returned geometry is Point, try to find polygon for this region specifically\n\tif gf and gf.get('geometry') and gf.get('geometry').get('type') == 'Point':\n\t\tpoly = find_polygon_for_feature(props)\n\t\tif poly:\n\t\t\tgf = poly\n\tresponse = {'file_key': key, 'neighborhood': props.get('name_en') or props.get('name_ar') or region_name or region_id, 'feature': gf, 'properties': props}",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tgf",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tgf = normalize_feature_to_geojson(feat)\n\t# If returned geometry is Point, try to find polygon for this region specifically\n\tif gf and gf.get('geometry') and gf.get('geometry').get('type') == 'Point':\n\t\tpoly = find_polygon_for_feature(props)\n\t\tif poly:\n\t\t\tgf = poly\n\tresponse = {'file_key': key, 'neighborhood': props.get('name_en') or props.get('name_ar') or region_name or region_id, 'feature': gf, 'properties': props}\n\t# attach any local population mapping if exists (match by region name)\n\tpop = load_region_populations()\n\tregion_name_key = response.get('neighborhood')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tpoly",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tpoly = find_polygon_for_feature(props)\n\t\tif poly:\n\t\t\tgf = poly\n\tresponse = {'file_key': key, 'neighborhood': props.get('name_en') or props.get('name_ar') or region_name or region_id, 'feature': gf, 'properties': props}\n\t# attach any local population mapping if exists (match by region name)\n\tpop = load_region_populations()\n\tregion_name_key = response.get('neighborhood')\n\tpop_entry = None\n\tif region_name_key:\n\t\tpop_entry = pop.get(region_name_key) or pop.get(region_name_key.strip().lower()) or pop.get(region_name_key.strip().upper())",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tgf",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tgf = poly\n\tresponse = {'file_key': key, 'neighborhood': props.get('name_en') or props.get('name_ar') or region_name or region_id, 'feature': gf, 'properties': props}\n\t# attach any local population mapping if exists (match by region name)\n\tpop = load_region_populations()\n\tregion_name_key = response.get('neighborhood')\n\tpop_entry = None\n\tif region_name_key:\n\t\tpop_entry = pop.get(region_name_key) or pop.get(region_name_key.strip().lower()) or pop.get(region_name_key.strip().upper())\n\tif pop_entry:\n\t\ttry:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tresponse",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tresponse = {'file_key': key, 'neighborhood': props.get('name_en') or props.get('name_ar') or region_name or region_id, 'feature': gf, 'properties': props}\n\t# attach any local population mapping if exists (match by region name)\n\tpop = load_region_populations()\n\tregion_name_key = response.get('neighborhood')\n\tpop_entry = None\n\tif region_name_key:\n\t\tpop_entry = pop.get(region_name_key) or pop.get(region_name_key.strip().lower()) or pop.get(region_name_key.strip().upper())\n\tif pop_entry:\n\t\ttry:\n\t\t\tmale = float(pop_entry.get('POP_M', 0))",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tpop",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tpop = load_region_populations()\n\tregion_name_key = response.get('neighborhood')\n\tpop_entry = None\n\tif region_name_key:\n\t\tpop_entry = pop.get(region_name_key) or pop.get(region_name_key.strip().lower()) or pop.get(region_name_key.strip().upper())\n\tif pop_entry:\n\t\ttry:\n\t\t\tmale = float(pop_entry.get('POP_M', 0))\n\t\texcept Exception:\n\t\t\tmale = 0",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tregion_name_key",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tregion_name_key = response.get('neighborhood')\n\tpop_entry = None\n\tif region_name_key:\n\t\tpop_entry = pop.get(region_name_key) or pop.get(region_name_key.strip().lower()) or pop.get(region_name_key.strip().upper())\n\tif pop_entry:\n\t\ttry:\n\t\t\tmale = float(pop_entry.get('POP_M', 0))\n\t\texcept Exception:\n\t\t\tmale = 0\n\t\ttry:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tpop_entry",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tpop_entry = None\n\tif region_name_key:\n\t\tpop_entry = pop.get(region_name_key) or pop.get(region_name_key.strip().lower()) or pop.get(region_name_key.strip().upper())\n\tif pop_entry:\n\t\ttry:\n\t\t\tmale = float(pop_entry.get('POP_M', 0))\n\t\texcept Exception:\n\t\t\tmale = 0\n\t\ttry:\n\t\t\tfemale = float(pop_entry.get('POP_F', 0))",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tpop_entry",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tpop_entry = pop.get(region_name_key) or pop.get(region_name_key.strip().lower()) or pop.get(region_name_key.strip().upper())\n\tif pop_entry:\n\t\ttry:\n\t\t\tmale = float(pop_entry.get('POP_M', 0))\n\t\texcept Exception:\n\t\t\tmale = 0\n\t\ttry:\n\t\t\tfemale = float(pop_entry.get('POP_F', 0))\n\t\texcept Exception:\n\t\t\tfemale = 0",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tmale",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tmale = float(pop_entry.get('POP_M', 0))\n\t\texcept Exception:\n\t\t\tmale = 0\n\t\ttry:\n\t\t\tfemale = float(pop_entry.get('POP_F', 0))\n\t\texcept Exception:\n\t\t\tfemale = 0\n\t\tresponse.update({'population_male': male, 'population_female': female, 'population_total': male + female})\n\treturn jsonify(response)\n@app.route('/city_districts')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tmale",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tmale = 0\n\t\ttry:\n\t\t\tfemale = float(pop_entry.get('POP_F', 0))\n\t\texcept Exception:\n\t\t\tfemale = 0\n\t\tresponse.update({'population_male': male, 'population_female': female, 'population_total': male + female})\n\treturn jsonify(response)\n@app.route('/city_districts')\ndef city_districts():\n\t\"\"\"Return a FeatureCollection of district features for a given city.",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tfemale",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tfemale = float(pop_entry.get('POP_F', 0))\n\t\texcept Exception:\n\t\t\tfemale = 0\n\t\tresponse.update({'population_male': male, 'population_female': female, 'population_total': male + female})\n\treturn jsonify(response)\n@app.route('/city_districts')\ndef city_districts():\n\t\"\"\"Return a FeatureCollection of district features for a given city.\n\tQuery params:\n\t- city_id (optional)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tfemale",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tfemale = 0\n\t\tresponse.update({'population_male': male, 'population_female': female, 'population_total': male + female})\n\treturn jsonify(response)\n@app.route('/city_districts')\ndef city_districts():\n\t\"\"\"Return a FeatureCollection of district features for a given city.\n\tQuery params:\n\t- city_id (optional)\n\t- city_name (optional)\n\t\"\"\"",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tcity_id",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tcity_id = request.args.get('city_id')\n\tcity_name = request.args.get('city_name')\n\tif not city_id and not city_name:\n\t\treturn jsonify({'error': 'missing city identifier'}), 400\n\t# load district files\n\tdistrict_keys = [k for k in ALLOWED_FILES.keys() if 'district' in k]\n\tfeatures = []\n\tdef _match_props(props):\n\t\tif city_id:\n\t\t\ttry:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tcity_name",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tcity_name = request.args.get('city_name')\n\tif not city_id and not city_name:\n\t\treturn jsonify({'error': 'missing city identifier'}), 400\n\t# load district files\n\tdistrict_keys = [k for k in ALLOWED_FILES.keys() if 'district' in k]\n\tfeatures = []\n\tdef _match_props(props):\n\t\tif city_id:\n\t\t\ttry:\n\t\t\t\tif str(props.get('city_id') or props.get('city') or '') == str(city_id):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tdistrict_keys",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tdistrict_keys = [k for k in ALLOWED_FILES.keys() if 'district' in k]\n\tfeatures = []\n\tdef _match_props(props):\n\t\tif city_id:\n\t\t\ttry:\n\t\t\t\tif str(props.get('city_id') or props.get('city') or '') == str(city_id):\n\t\t\t\t\treturn True\n\t\t\texcept Exception:\n\t\t\t\tpass\n\t\tif city_name:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tfeatures",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tfeatures = []\n\tdef _match_props(props):\n\t\tif city_id:\n\t\t\ttry:\n\t\t\t\tif str(props.get('city_id') or props.get('city') or '') == str(city_id):\n\t\t\t\t\treturn True\n\t\t\texcept Exception:\n\t\t\t\tpass\n\t\tif city_name:\n\t\t\tneedle = str(city_name).strip().lower()",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tneedle",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tneedle = str(city_name).strip().lower()\n\t\t\tfor nk in ('name_en','name_ar','name','CITY','city'):\n\t\t\t\tv = props.get(nk)\n\t\t\t\tif v and str(v).strip().lower() == needle:\n\t\t\t\t\treturn True\n\t\treturn False\n\tfor key in district_keys:\n\t\tdata = load_external_file(key)\n\t\tfor feat in data.get('features', []):\n\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tv",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tv = props.get(nk)\n\t\t\t\tif v and str(v).strip().lower() == needle:\n\t\t\t\t\treturn True\n\t\treturn False\n\tfor key in district_keys:\n\t\tdata = load_external_file(key)\n\t\tfor feat in data.get('features', []):\n\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat\n\t\t\tif _match_props(props):\n\t\t\t\tgf = normalize_feature_to_geojson(feat)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tdata",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tdata = load_external_file(key)\n\t\tfor feat in data.get('features', []):\n\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat\n\t\t\tif _match_props(props):\n\t\t\t\tgf = normalize_feature_to_geojson(feat)\n\t\t\t\tfeatures.append(gf)\n\t# If no districts found, return an empty FeatureCollection (200).\n\t# Client will fallback to drawing the city itself when collection is empty.\n\treturn jsonify({'type': 'FeatureCollection', 'features': features})\ndef query_all_files(neighborhood_value, name_field_candidates=None):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tprops",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat\n\t\t\tif _match_props(props):\n\t\t\t\tgf = normalize_feature_to_geojson(feat)\n\t\t\t\tfeatures.append(gf)\n\t# If no districts found, return an empty FeatureCollection (200).\n\t# Client will fallback to drawing the city itself when collection is empty.\n\treturn jsonify({'type': 'FeatureCollection', 'features': features})\ndef query_all_files(neighborhood_value, name_field_candidates=None):\n\t\"\"\"Search all allowed files in order and return the first matching feature.\n\tReturns a tuple (key, feature) or (None, None) if not found.",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tgf",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tgf = normalize_feature_to_geojson(feat)\n\t\t\t\tfeatures.append(gf)\n\t# If no districts found, return an empty FeatureCollection (200).\n\t# Client will fallback to drawing the city itself when collection is empty.\n\treturn jsonify({'type': 'FeatureCollection', 'features': features})\ndef query_all_files(neighborhood_value, name_field_candidates=None):\n\t\"\"\"Search all allowed files in order and return the first matching feature.\n\tReturns a tuple (key, feature) or (None, None) if not found.\n\t\"\"\"\n\tfor key in ALLOWED_FILES.keys():",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tfeat",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tfeat = query_file_feature(key, neighborhood_value, name_field_candidates)\n\t\tif feat:\n\t\t\treturn key, feat\n\treturn None, None\ndef query_all_matches(query_value, name_field_candidates=None, limit=50):\n\t\"\"\"Return a list of matching candidate features across all allowed files.\n\tMatching is performed by case-insensitive substring match against common name fields.\n\tReturns list of dicts: {file_key, id, name_en, name_ar, props}\n\t\"\"\"\n\tq = (query_value or '').strip().lower()",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tq",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tq = (query_value or '').strip().lower()\n\tif not q:\n\t\treturn []\n\tif name_field_candidates is None:\n\t\tname_field_candidates = [\n\t\t\t'name', 'NAME', 'Name',\n\t\t\t'name_en', 'NAME_EN', 'EN_NAME', 'nameEn',\n\t\t\t'name_ar', 'NAME_AR', 'AR_NAME', 'nameAr'\n\t\t]\n\tresults = []",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tname_field_candidates",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tname_field_candidates = [\n\t\t\t'name', 'NAME', 'Name',\n\t\t\t'name_en', 'NAME_EN', 'EN_NAME', 'nameEn',\n\t\t\t'name_ar', 'NAME_AR', 'AR_NAME', 'nameAr'\n\t\t]\n\tresults = []\n\tfor key in ALLOWED_FILES.keys():\n\t\tdata = load_external_file(key)\n\t\tfor feat in data.get('features', []):\n\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tresults",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tresults = []\n\tfor key in ALLOWED_FILES.keys():\n\t\tdata = load_external_file(key)\n\t\tfor feat in data.get('features', []):\n\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat\n\t\t\tcandidate_names = []\n\t\t\tfor nf in name_field_candidates:\n\t\t\t\tv = props.get(nf)\n\t\t\t\tif v:\n\t\t\t\t\tcandidate_names.append(str(v).strip())",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tdata",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tdata = load_external_file(key)\n\t\tfor feat in data.get('features', []):\n\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat\n\t\t\tcandidate_names = []\n\t\t\tfor nf in name_field_candidates:\n\t\t\t\tv = props.get(nf)\n\t\t\t\tif v:\n\t\t\t\t\tcandidate_names.append(str(v).strip())\n\t\t\t# also include combined display name\n\t\t\tdisplay_name = None",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tprops",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tprops = feat.get('properties') if isinstance(feat, dict) and 'properties' in feat else feat\n\t\t\tcandidate_names = []\n\t\t\tfor nf in name_field_candidates:\n\t\t\t\tv = props.get(nf)\n\t\t\t\tif v:\n\t\t\t\t\tcandidate_names.append(str(v).strip())\n\t\t\t# also include combined display name\n\t\t\tdisplay_name = None\n\t\t\tif candidate_names:\n\t\t\t\tdisplay_name = candidate_names[0]",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tcandidate_names",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tcandidate_names = []\n\t\t\tfor nf in name_field_candidates:\n\t\t\t\tv = props.get(nf)\n\t\t\t\tif v:\n\t\t\t\t\tcandidate_names.append(str(v).strip())\n\t\t\t# also include combined display name\n\t\t\tdisplay_name = None\n\t\t\tif candidate_names:\n\t\t\t\tdisplay_name = candidate_names[0]\n\t\t\t# perform substring match on available names",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tv",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tv = props.get(nf)\n\t\t\t\tif v:\n\t\t\t\t\tcandidate_names.append(str(v).strip())\n\t\t\t# also include combined display name\n\t\t\tdisplay_name = None\n\t\t\tif candidate_names:\n\t\t\t\tdisplay_name = candidate_names[0]\n\t\t\t# perform substring match on available names\n\t\t\tmatch = False\n\t\t\tfor cname in candidate_names:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tdisplay_name",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tdisplay_name = None\n\t\t\tif candidate_names:\n\t\t\t\tdisplay_name = candidate_names[0]\n\t\t\t# perform substring match on available names\n\t\t\tmatch = False\n\t\t\tfor cname in candidate_names:\n\t\t\t\tif q in cname.lower():\n\t\t\t\t\tmatch = True\n\t\t\t\t\tbreak\n\t\t\tif match:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tdisplay_name",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tdisplay_name = candidate_names[0]\n\t\t\t# perform substring match on available names\n\t\t\tmatch = False\n\t\t\tfor cname in candidate_names:\n\t\t\t\tif q in cname.lower():\n\t\t\t\t\tmatch = True\n\t\t\t\t\tbreak\n\t\t\tif match:\n\t\t\t\t# id extraction\n\t\t\t\tid_val = None",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tmatch",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tmatch = False\n\t\t\tfor cname in candidate_names:\n\t\t\t\tif q in cname.lower():\n\t\t\t\t\tmatch = True\n\t\t\t\t\tbreak\n\t\t\tif match:\n\t\t\t\t# id extraction\n\t\t\t\tid_val = None\n\t\t\t\tfor ik in ('id','city_id','region_id','district_id'):\n\t\t\t\t\tif ik in props:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tmatch",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\tmatch = True\n\t\t\t\t\tbreak\n\t\t\tif match:\n\t\t\t\t# id extraction\n\t\t\t\tid_val = None\n\t\t\t\tfor ik in ('id','city_id','region_id','district_id'):\n\t\t\t\t\tif ik in props:\n\t\t\t\t\t\tid_val = props.get(ik)\n\t\t\t\t\t\tbreak\n\t\t\t\tresults.append({'file_key': key, 'id': id_val, 'name_en': props.get('name_en') or props.get('NAME') or props.get('name'), 'name_ar': props.get('name_ar') or props.get('NAME') or props.get('name'), 'props': props})",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tid_val",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tid_val = None\n\t\t\t\tfor ik in ('id','city_id','region_id','district_id'):\n\t\t\t\t\tif ik in props:\n\t\t\t\t\t\tid_val = props.get(ik)\n\t\t\t\t\t\tbreak\n\t\t\t\tresults.append({'file_key': key, 'id': id_val, 'name_en': props.get('name_en') or props.get('NAME') or props.get('name'), 'name_ar': props.get('name_ar') or props.get('NAME') or props.get('name'), 'props': props})\n\t\t\t\tif len(results) >= limit:\n\t\t\t\t\treturn results\n\treturn results\n@app.route('/stats_search_all')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\t\tid_val",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\t\tid_val = props.get(ik)\n\t\t\t\t\t\tbreak\n\t\t\t\tresults.append({'file_key': key, 'id': id_val, 'name_en': props.get('name_en') or props.get('NAME') or props.get('name'), 'name_ar': props.get('name_ar') or props.get('NAME') or props.get('name'), 'props': props})\n\t\t\t\tif len(results) >= limit:\n\t\t\t\t\treturn results\n\treturn results\n@app.route('/stats_search_all')\ndef stats_search_all():\n\t\"\"\"Search across all provided geojson/json files for a neighborhood name.\n\tQuery params:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tneighborhood",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tneighborhood = request.args.get('neighborhood')\n\tif not neighborhood:\n\t\treturn jsonify({'error': 'missing neighborhood parameter'}), 400\n\tname_field_param = request.args.get('name_field')\n\tcandidates = None\n\tif name_field_param:\n\t\tcandidates = [s.strip() for s in name_field_param.split(',') if s.strip()]\n\tkey, feat = query_all_files(neighborhood, candidates)\n\tif not feat:\n\t\treturn jsonify({'error': 'not found in allowed files'}), 404",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tname_field_param",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tname_field_param = request.args.get('name_field')\n\tcandidates = None\n\tif name_field_param:\n\t\tcandidates = [s.strip() for s in name_field_param.split(',') if s.strip()]\n\tkey, feat = query_all_files(neighborhood, candidates)\n\tif not feat:\n\t\treturn jsonify({'error': 'not found in allowed files'}), 404\n\t# normalize to GeoJSON feature where possible\n\tgf = normalize_feature_to_geojson(feat)\n\tprops = gf.get('properties', {}) if isinstance(gf, dict) else {}",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tcandidates",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tcandidates = None\n\tif name_field_param:\n\t\tcandidates = [s.strip() for s in name_field_param.split(',') if s.strip()]\n\tkey, feat = query_all_files(neighborhood, candidates)\n\tif not feat:\n\t\treturn jsonify({'error': 'not found in allowed files'}), 404\n\t# normalize to GeoJSON feature where possible\n\tgf = normalize_feature_to_geojson(feat)\n\tprops = gf.get('properties', {}) if isinstance(gf, dict) else {}\n\tregion_name = props.get('name') or props.get('NAME') or props.get('EN_NAME') or props.get('name_en') or props.get('name_ar') or neighborhood",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tcandidates",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tcandidates = [s.strip() for s in name_field_param.split(',') if s.strip()]\n\tkey, feat = query_all_files(neighborhood, candidates)\n\tif not feat:\n\t\treturn jsonify({'error': 'not found in allowed files'}), 404\n\t# normalize to GeoJSON feature where possible\n\tgf = normalize_feature_to_geojson(feat)\n\tprops = gf.get('properties', {}) if isinstance(gf, dict) else {}\n\tregion_name = props.get('name') or props.get('NAME') or props.get('EN_NAME') or props.get('name_en') or props.get('name_ar') or neighborhood\n\tpop = load_region_populations()\n\tpop_entry = None",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tgf",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tgf = normalize_feature_to_geojson(feat)\n\tprops = gf.get('properties', {}) if isinstance(gf, dict) else {}\n\tregion_name = props.get('name') or props.get('NAME') or props.get('EN_NAME') or props.get('name_en') or props.get('name_ar') or neighborhood\n\tpop = load_region_populations()\n\tpop_entry = None\n\tif region_name:\n\t\tpop_entry = pop.get(region_name) or pop.get(region_name.strip().lower()) or pop.get(region_name.strip().upper())\n\t# If the normalized feature is a Point (city center), try finding a polygon for it\n\tif isinstance(gf, dict) and gf.get('geometry') and gf.get('geometry').get('type') == 'Point':\n\t\tpoly = find_polygon_for_feature(props)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tprops",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tprops = gf.get('properties', {}) if isinstance(gf, dict) else {}\n\tregion_name = props.get('name') or props.get('NAME') or props.get('EN_NAME') or props.get('name_en') or props.get('name_ar') or neighborhood\n\tpop = load_region_populations()\n\tpop_entry = None\n\tif region_name:\n\t\tpop_entry = pop.get(region_name) or pop.get(region_name.strip().lower()) or pop.get(region_name.strip().upper())\n\t# If the normalized feature is a Point (city center), try finding a polygon for it\n\tif isinstance(gf, dict) and gf.get('geometry') and gf.get('geometry').get('type') == 'Point':\n\t\tpoly = find_polygon_for_feature(props)\n\t\tif poly:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tregion_name",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tregion_name = props.get('name') or props.get('NAME') or props.get('EN_NAME') or props.get('name_en') or props.get('name_ar') or neighborhood\n\tpop = load_region_populations()\n\tpop_entry = None\n\tif region_name:\n\t\tpop_entry = pop.get(region_name) or pop.get(region_name.strip().lower()) or pop.get(region_name.strip().upper())\n\t# If the normalized feature is a Point (city center), try finding a polygon for it\n\tif isinstance(gf, dict) and gf.get('geometry') and gf.get('geometry').get('type') == 'Point':\n\t\tpoly = find_polygon_for_feature(props)\n\t\tif poly:\n\t\t\tgf = poly",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tpop",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tpop = load_region_populations()\n\tpop_entry = None\n\tif region_name:\n\t\tpop_entry = pop.get(region_name) or pop.get(region_name.strip().lower()) or pop.get(region_name.strip().upper())\n\t# If the normalized feature is a Point (city center), try finding a polygon for it\n\tif isinstance(gf, dict) and gf.get('geometry') and gf.get('geometry').get('type') == 'Point':\n\t\tpoly = find_polygon_for_feature(props)\n\t\tif poly:\n\t\t\tgf = poly\n\tresponse = {'file_key': key, 'neighborhood': region_name, 'feature': gf, 'properties': props}",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tpop_entry",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tpop_entry = None\n\tif region_name:\n\t\tpop_entry = pop.get(region_name) or pop.get(region_name.strip().lower()) or pop.get(region_name.strip().upper())\n\t# If the normalized feature is a Point (city center), try finding a polygon for it\n\tif isinstance(gf, dict) and gf.get('geometry') and gf.get('geometry').get('type') == 'Point':\n\t\tpoly = find_polygon_for_feature(props)\n\t\tif poly:\n\t\t\tgf = poly\n\tresponse = {'file_key': key, 'neighborhood': region_name, 'feature': gf, 'properties': props}\n\tif pop_entry:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tpop_entry",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tpop_entry = pop.get(region_name) or pop.get(region_name.strip().lower()) or pop.get(region_name.strip().upper())\n\t# If the normalized feature is a Point (city center), try finding a polygon for it\n\tif isinstance(gf, dict) and gf.get('geometry') and gf.get('geometry').get('type') == 'Point':\n\t\tpoly = find_polygon_for_feature(props)\n\t\tif poly:\n\t\t\tgf = poly\n\tresponse = {'file_key': key, 'neighborhood': region_name, 'feature': gf, 'properties': props}\n\tif pop_entry:\n\t\ttry:\n\t\t\tmale = float(pop_entry.get('POP_M', 0))",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tpoly",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tpoly = find_polygon_for_feature(props)\n\t\tif poly:\n\t\t\tgf = poly\n\tresponse = {'file_key': key, 'neighborhood': region_name, 'feature': gf, 'properties': props}\n\tif pop_entry:\n\t\ttry:\n\t\t\tmale = float(pop_entry.get('POP_M', 0))\n\t\texcept Exception:\n\t\t\tmale = 0\n\t\ttry:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tgf",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tgf = poly\n\tresponse = {'file_key': key, 'neighborhood': region_name, 'feature': gf, 'properties': props}\n\tif pop_entry:\n\t\ttry:\n\t\t\tmale = float(pop_entry.get('POP_M', 0))\n\t\texcept Exception:\n\t\t\tmale = 0\n\t\ttry:\n\t\t\tfemale = float(pop_entry.get('POP_F', 0))\n\t\texcept Exception:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tresponse",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tresponse = {'file_key': key, 'neighborhood': region_name, 'feature': gf, 'properties': props}\n\tif pop_entry:\n\t\ttry:\n\t\t\tmale = float(pop_entry.get('POP_M', 0))\n\t\texcept Exception:\n\t\t\tmale = 0\n\t\ttry:\n\t\t\tfemale = float(pop_entry.get('POP_F', 0))\n\t\texcept Exception:\n\t\t\tfemale = 0",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tmale",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tmale = float(pop_entry.get('POP_M', 0))\n\t\texcept Exception:\n\t\t\tmale = 0\n\t\ttry:\n\t\t\tfemale = float(pop_entry.get('POP_F', 0))\n\t\texcept Exception:\n\t\t\tfemale = 0\n\t\tresponse.update({'population_male': male, 'population_female': female, 'population_total': male + female})\n\treturn jsonify(response)\n@app.route('/search_suggest')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tmale",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tmale = 0\n\t\ttry:\n\t\t\tfemale = float(pop_entry.get('POP_F', 0))\n\t\texcept Exception:\n\t\t\tfemale = 0\n\t\tresponse.update({'population_male': male, 'population_female': female, 'population_total': male + female})\n\treturn jsonify(response)\n@app.route('/search_suggest')\ndef search_suggest():\n\t\"\"\"Return a list of matching name suggestions across allowed files.",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tfemale",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tfemale = float(pop_entry.get('POP_F', 0))\n\t\texcept Exception:\n\t\t\tfemale = 0\n\t\tresponse.update({'population_male': male, 'population_female': female, 'population_total': male + female})\n\treturn jsonify(response)\n@app.route('/search_suggest')\ndef search_suggest():\n\t\"\"\"Return a list of matching name suggestions across allowed files.\n\tQuery params:\n\t- q: query string (required)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tfemale",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tfemale = 0\n\t\tresponse.update({'population_male': male, 'population_female': female, 'population_total': male + female})\n\treturn jsonify(response)\n@app.route('/search_suggest')\ndef search_suggest():\n\t\"\"\"Return a list of matching name suggestions across allowed files.\n\tQuery params:\n\t- q: query string (required)\n\t- limit: max results (optional)\n\t\"\"\"",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tq",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tq = request.args.get('q')\n\tif not q:\n\t\treturn jsonify({'error': 'missing q parameter'}), 400\n\ttry:\n\t\tlimit = int(request.args.get('limit') or 50)\n\texcept Exception:\n\t\tlimit = 50\n\tmatches = query_all_matches(q, limit=limit)\n\t# Prepare simple suggestion objects\n\tout = []",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tlimit",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tlimit = int(request.args.get('limit') or 50)\n\texcept Exception:\n\t\tlimit = 50\n\tmatches = query_all_matches(q, limit=limit)\n\t# Prepare simple suggestion objects\n\tout = []\n\tfor m in matches:\n\t\tout.append({'file_key': m.get('file_key'), 'id': m.get('id'), 'name_en': m.get('name_en'), 'name_ar': m.get('name_ar'), 'props': m.get('props')})\n\treturn jsonify({'suggestions': out})\n# --- Listing endpoints for cascading dropdowns ---",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tlimit",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tlimit = 50\n\tmatches = query_all_matches(q, limit=limit)\n\t# Prepare simple suggestion objects\n\tout = []\n\tfor m in matches:\n\t\tout.append({'file_key': m.get('file_key'), 'id': m.get('id'), 'name_en': m.get('name_en'), 'name_ar': m.get('name_ar'), 'props': m.get('props')})\n\treturn jsonify({'suggestions': out})\n# --- Listing endpoints for cascading dropdowns ---\ndef _load_list_from_key(key, id_field_candidates=('id','region_id','city_id'), name_field_candidates=('name_en','name_ar','name','NAME')):\n\t\"\"\"Return list of dicts {id:, name_en:, name_ar:, props:...} from allowed file key.\"\"\"",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tmatches",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tmatches = query_all_matches(q, limit=limit)\n\t# Prepare simple suggestion objects\n\tout = []\n\tfor m in matches:\n\t\tout.append({'file_key': m.get('file_key'), 'id': m.get('id'), 'name_en': m.get('name_en'), 'name_ar': m.get('name_ar'), 'props': m.get('props')})\n\treturn jsonify({'suggestions': out})\n# --- Listing endpoints for cascading dropdowns ---\ndef _load_list_from_key(key, id_field_candidates=('id','region_id','city_id'), name_field_candidates=('name_en','name_ar','name','NAME')):\n\t\"\"\"Return list of dicts {id:, name_en:, name_ar:, props:...} from allowed file key.\"\"\"\n\tdata = load_external_file(key)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tout",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tout = []\n\tfor m in matches:\n\t\tout.append({'file_key': m.get('file_key'), 'id': m.get('id'), 'name_en': m.get('name_en'), 'name_ar': m.get('name_ar'), 'props': m.get('props')})\n\treturn jsonify({'suggestions': out})\n# --- Listing endpoints for cascading dropdowns ---\ndef _load_list_from_key(key, id_field_candidates=('id','region_id','city_id'), name_field_candidates=('name_en','name_ar','name','NAME')):\n\t\"\"\"Return list of dicts {id:, name_en:, name_ar:, props:...} from allowed file key.\"\"\"\n\tdata = load_external_file(key)\n\tout = []\n\tfor item in data.get('features', []):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tdata",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tdata = load_external_file(key)\n\tout = []\n\tfor item in data.get('features', []):\n\t\tprops = item.get('properties') if isinstance(item, dict) and 'properties' in item else item\n\t\t# find id\n\t\tid_val = None\n\t\tfor f in id_field_candidates:\n\t\t\tif f in props:\n\t\t\t\tid_val = props.get(f)\n\t\t\t\tbreak",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tout",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tout = []\n\tfor item in data.get('features', []):\n\t\tprops = item.get('properties') if isinstance(item, dict) and 'properties' in item else item\n\t\t# find id\n\t\tid_val = None\n\t\tfor f in id_field_candidates:\n\t\t\tif f in props:\n\t\t\t\tid_val = props.get(f)\n\t\t\t\tbreak\n\t\t# find name variants",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tprops",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tprops = item.get('properties') if isinstance(item, dict) and 'properties' in item else item\n\t\t# find id\n\t\tid_val = None\n\t\tfor f in id_field_candidates:\n\t\t\tif f in props:\n\t\t\t\tid_val = props.get(f)\n\t\t\t\tbreak\n\t\t# find name variants\n\t\tname_en = props.get('name_en') or props.get('name_en'.upper()) or props.get('name_en'.lower()) or props.get('name_en')\n\t\tname_en = name_en or props.get('name_en')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tid_val",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tid_val = None\n\t\tfor f in id_field_candidates:\n\t\t\tif f in props:\n\t\t\t\tid_val = props.get(f)\n\t\t\t\tbreak\n\t\t# find name variants\n\t\tname_en = props.get('name_en') or props.get('name_en'.upper()) or props.get('name_en'.lower()) or props.get('name_en')\n\t\tname_en = name_en or props.get('name_en')\n\t\tname_en = name_en or props.get('name_en')\n\t\tname_en = name_en or props.get('name_en')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tid_val",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\tid_val = props.get(f)\n\t\t\t\tbreak\n\t\t# find name variants\n\t\tname_en = props.get('name_en') or props.get('name_en'.upper()) or props.get('name_en'.lower()) or props.get('name_en')\n\t\tname_en = name_en or props.get('name_en')\n\t\tname_en = name_en or props.get('name_en')\n\t\tname_en = name_en or props.get('name_en')\n\t\tname_ar = props.get('name_ar') or props.get('name_ar'.upper()) or props.get('name_ar'.lower())\n\t\tif not name_en and 'name_en' in props:\n\t\t\tname_en = props.get('name_en')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tname_en",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tname_en = props.get('name_en') or props.get('name_en'.upper()) or props.get('name_en'.lower()) or props.get('name_en')\n\t\tname_en = name_en or props.get('name_en')\n\t\tname_en = name_en or props.get('name_en')\n\t\tname_en = name_en or props.get('name_en')\n\t\tname_ar = props.get('name_ar') or props.get('name_ar'.upper()) or props.get('name_ar'.lower())\n\t\tif not name_en and 'name_en' in props:\n\t\t\tname_en = props.get('name_en')\n\t\t# fallback to common keys\n\t\tif not name_en:\n\t\t\tfor k in ('name_en','name','NAME','name_en','name_en'):",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tname_en",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tname_en = name_en or props.get('name_en')\n\t\tname_en = name_en or props.get('name_en')\n\t\tname_en = name_en or props.get('name_en')\n\t\tname_ar = props.get('name_ar') or props.get('name_ar'.upper()) or props.get('name_ar'.lower())\n\t\tif not name_en and 'name_en' in props:\n\t\t\tname_en = props.get('name_en')\n\t\t# fallback to common keys\n\t\tif not name_en:\n\t\t\tfor k in ('name_en','name','NAME','name_en','name_en'):\n\t\t\t\tif k in props:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tname_en",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tname_en = name_en or props.get('name_en')\n\t\tname_en = name_en or props.get('name_en')\n\t\tname_ar = props.get('name_ar') or props.get('name_ar'.upper()) or props.get('name_ar'.lower())\n\t\tif not name_en and 'name_en' in props:\n\t\t\tname_en = props.get('name_en')\n\t\t# fallback to common keys\n\t\tif not name_en:\n\t\t\tfor k in ('name_en','name','NAME','name_en','name_en'):\n\t\t\t\tif k in props:\n\t\t\t\t\tname_en = props.get(k)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tname_en",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tname_en = name_en or props.get('name_en')\n\t\tname_ar = props.get('name_ar') or props.get('name_ar'.upper()) or props.get('name_ar'.lower())\n\t\tif not name_en and 'name_en' in props:\n\t\t\tname_en = props.get('name_en')\n\t\t# fallback to common keys\n\t\tif not name_en:\n\t\t\tfor k in ('name_en','name','NAME','name_en','name_en'):\n\t\t\t\tif k in props:\n\t\t\t\t\tname_en = props.get(k)\n\t\t\t\t\tbreak",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tname_ar",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tname_ar = props.get('name_ar') or props.get('name_ar'.upper()) or props.get('name_ar'.lower())\n\t\tif not name_en and 'name_en' in props:\n\t\t\tname_en = props.get('name_en')\n\t\t# fallback to common keys\n\t\tif not name_en:\n\t\t\tfor k in ('name_en','name','NAME','name_en','name_en'):\n\t\t\t\tif k in props:\n\t\t\t\t\tname_en = props.get(k)\n\t\t\t\t\tbreak\n\t\tif not name_ar:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tname_en",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tname_en = props.get('name_en')\n\t\t# fallback to common keys\n\t\tif not name_en:\n\t\t\tfor k in ('name_en','name','NAME','name_en','name_en'):\n\t\t\t\tif k in props:\n\t\t\t\t\tname_en = props.get(k)\n\t\t\t\t\tbreak\n\t\tif not name_ar:\n\t\t\tfor k in ('name_ar','NAME_AR','name','NAME'):\n\t\t\t\tif k in props:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tname_en",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\tname_en = props.get(k)\n\t\t\t\t\tbreak\n\t\tif not name_ar:\n\t\t\tfor k in ('name_ar','NAME_AR','name','NAME'):\n\t\t\t\tif k in props:\n\t\t\t\t\tname_ar = props.get(k)\n\t\t\t\t\tbreak\n\t\tout.append({'id': id_val, 'name_en': name_en, 'name_ar': name_ar, 'props': props})\n\treturn out\n@app.route('/list_regions')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\t\tname_ar",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\t\tname_ar = props.get(k)\n\t\t\t\t\tbreak\n\t\tout.append({'id': id_val, 'name_en': name_en, 'name_ar': name_ar, 'props': props})\n\treturn out\n@app.route('/list_regions')\ndef list_regions():\n\t# prefer json/regions.json then geojson/regions.geojson\n\tregions = _load_list_from_key('json_regions') if 'json_regions' in ALLOWED_FILES else []\n\tif not regions and 'geo_regions' in ALLOWED_FILES:\n\t\tregions = _load_list_from_key('geo_regions')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tregions",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tregions = _load_list_from_key('json_regions') if 'json_regions' in ALLOWED_FILES else []\n\tif not regions and 'geo_regions' in ALLOWED_FILES:\n\t\tregions = _load_list_from_key('geo_regions')\n\t# remove duplicates and sort\n\tseen = set()\n\tout = []\n\tfor r in regions:\n\t\tkey = (str(r.get('id')), str(r.get('name_en') or r.get('name_ar') or ''))\n\t\tif key in seen:\n\t\t\tcontinue",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tregions",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tregions = _load_list_from_key('geo_regions')\n\t# remove duplicates and sort\n\tseen = set()\n\tout = []\n\tfor r in regions:\n\t\tkey = (str(r.get('id')), str(r.get('name_en') or r.get('name_ar') or ''))\n\t\tif key in seen:\n\t\t\tcontinue\n\t\tseen.add(key)\n\t\tout.append({'id': r.get('id'), 'name_en': r.get('name_en'), 'name_ar': r.get('name_ar')})",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tseen",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tseen = set()\n\tout = []\n\tfor r in regions:\n\t\tkey = (str(r.get('id')), str(r.get('name_en') or r.get('name_ar') or ''))\n\t\tif key in seen:\n\t\t\tcontinue\n\t\tseen.add(key)\n\t\tout.append({'id': r.get('id'), 'name_en': r.get('name_en'), 'name_ar': r.get('name_ar')})\n\treturn jsonify({'regions': out})\n@app.route('/list_cities')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tout",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tout = []\n\tfor r in regions:\n\t\tkey = (str(r.get('id')), str(r.get('name_en') or r.get('name_ar') or ''))\n\t\tif key in seen:\n\t\t\tcontinue\n\t\tseen.add(key)\n\t\tout.append({'id': r.get('id'), 'name_en': r.get('name_en'), 'name_ar': r.get('name_ar')})\n\treturn jsonify({'regions': out})\n@app.route('/list_cities')\ndef list_cities():",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tkey",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tkey = (str(r.get('id')), str(r.get('name_en') or r.get('name_ar') or ''))\n\t\tif key in seen:\n\t\t\tcontinue\n\t\tseen.add(key)\n\t\tout.append({'id': r.get('id'), 'name_en': r.get('name_en'), 'name_ar': r.get('name_ar')})\n\treturn jsonify({'regions': out})\n@app.route('/list_cities')\ndef list_cities():\n\t# Accept either region_id or region_name\n\tregion_id = request.args.get('region_id')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tregion_id",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tregion_id = request.args.get('region_id')\n\tregion_name = request.args.get('region_name')\n\t# load cities from json_cities or geo_cities\n\tcities = []\n\tif 'json_cities' in ALLOWED_FILES:\n\t\tcities = _load_list_from_key('json_cities', id_field_candidates=('city_id',), name_field_candidates=('name_en','name_ar'))\n\telif 'geo_cities' in ALLOWED_FILES:\n\t\tcities = _load_list_from_key('geo_cities', id_field_candidates=('city_id',), name_field_candidates=('name_en','name_ar'))\n\tif region_id:\n\t\ttry:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tregion_name",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tregion_name = request.args.get('region_name')\n\t# load cities from json_cities or geo_cities\n\tcities = []\n\tif 'json_cities' in ALLOWED_FILES:\n\t\tcities = _load_list_from_key('json_cities', id_field_candidates=('city_id',), name_field_candidates=('name_en','name_ar'))\n\telif 'geo_cities' in ALLOWED_FILES:\n\t\tcities = _load_list_from_key('geo_cities', id_field_candidates=('city_id',), name_field_candidates=('name_en','name_ar'))\n\tif region_id:\n\t\ttry:\n\t\t\trid = int(region_id)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tcities",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tcities = []\n\tif 'json_cities' in ALLOWED_FILES:\n\t\tcities = _load_list_from_key('json_cities', id_field_candidates=('city_id',), name_field_candidates=('name_en','name_ar'))\n\telif 'geo_cities' in ALLOWED_FILES:\n\t\tcities = _load_list_from_key('geo_cities', id_field_candidates=('city_id',), name_field_candidates=('name_en','name_ar'))\n\tif region_id:\n\t\ttry:\n\t\t\trid = int(region_id)\n\t\t\tcities = [c for c in cities if c.get('props', {}).get('region_id') == rid or c.get('props', {}).get('region_id') == str(rid)]\n\t\texcept Exception:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tcities",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tcities = _load_list_from_key('json_cities', id_field_candidates=('city_id',), name_field_candidates=('name_en','name_ar'))\n\telif 'geo_cities' in ALLOWED_FILES:\n\t\tcities = _load_list_from_key('geo_cities', id_field_candidates=('city_id',), name_field_candidates=('name_en','name_ar'))\n\tif region_id:\n\t\ttry:\n\t\t\trid = int(region_id)\n\t\t\tcities = [c for c in cities if c.get('props', {}).get('region_id') == rid or c.get('props', {}).get('region_id') == str(rid)]\n\t\texcept Exception:\n\t\t\tpass\n\telif region_name:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tcities",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tcities = _load_list_from_key('geo_cities', id_field_candidates=('city_id',), name_field_candidates=('name_en','name_ar'))\n\tif region_id:\n\t\ttry:\n\t\t\trid = int(region_id)\n\t\t\tcities = [c for c in cities if c.get('props', {}).get('region_id') == rid or c.get('props', {}).get('region_id') == str(rid)]\n\t\texcept Exception:\n\t\t\tpass\n\telif region_name:\n\t\t# find region id by name\n\t\tregs = _load_list_from_key('json_regions') if 'json_regions' in ALLOWED_FILES else _load_list_from_key('geo_regions')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\trid",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\trid = int(region_id)\n\t\t\tcities = [c for c in cities if c.get('props', {}).get('region_id') == rid or c.get('props', {}).get('region_id') == str(rid)]\n\t\texcept Exception:\n\t\t\tpass\n\telif region_name:\n\t\t# find region id by name\n\t\tregs = _load_list_from_key('json_regions') if 'json_regions' in ALLOWED_FILES else _load_list_from_key('geo_regions')\n\t\ttarget = None\n\t\tneedle = (region_name or '').strip().lower()\n\t\tfor r in regs:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tcities",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tcities = [c for c in cities if c.get('props', {}).get('region_id') == rid or c.get('props', {}).get('region_id') == str(rid)]\n\t\texcept Exception:\n\t\t\tpass\n\telif region_name:\n\t\t# find region id by name\n\t\tregs = _load_list_from_key('json_regions') if 'json_regions' in ALLOWED_FILES else _load_list_from_key('geo_regions')\n\t\ttarget = None\n\t\tneedle = (region_name or '').strip().lower()\n\t\tfor r in regs:\n\t\t\tif r.get('name_en') and str(r.get('name_en')).strip().lower() == needle:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tregs",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tregs = _load_list_from_key('json_regions') if 'json_regions' in ALLOWED_FILES else _load_list_from_key('geo_regions')\n\t\ttarget = None\n\t\tneedle = (region_name or '').strip().lower()\n\t\tfor r in regs:\n\t\t\tif r.get('name_en') and str(r.get('name_en')).strip().lower() == needle:\n\t\t\t\ttarget = r.get('id')\n\t\t\t\tbreak\n\t\t\tif r.get('name_ar') and str(r.get('name_ar')).strip().lower() == needle:\n\t\t\t\ttarget = r.get('id')\n\t\t\t\tbreak",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\ttarget",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\ttarget = None\n\t\tneedle = (region_name or '').strip().lower()\n\t\tfor r in regs:\n\t\t\tif r.get('name_en') and str(r.get('name_en')).strip().lower() == needle:\n\t\t\t\ttarget = r.get('id')\n\t\t\t\tbreak\n\t\t\tif r.get('name_ar') and str(r.get('name_ar')).strip().lower() == needle:\n\t\t\t\ttarget = r.get('id')\n\t\t\t\tbreak\n\t\tif target is not None:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tneedle",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tneedle = (region_name or '').strip().lower()\n\t\tfor r in regs:\n\t\t\tif r.get('name_en') and str(r.get('name_en')).strip().lower() == needle:\n\t\t\t\ttarget = r.get('id')\n\t\t\t\tbreak\n\t\t\tif r.get('name_ar') and str(r.get('name_ar')).strip().lower() == needle:\n\t\t\t\ttarget = r.get('id')\n\t\t\t\tbreak\n\t\tif target is not None:\n\t\t\tcities = [c for c in cities if c.get('props', {}).get('region_id') == target or c.get('props', {}).get('region_id') == str(target)]",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ttarget",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\ttarget = r.get('id')\n\t\t\t\tbreak\n\t\t\tif r.get('name_ar') and str(r.get('name_ar')).strip().lower() == needle:\n\t\t\t\ttarget = r.get('id')\n\t\t\t\tbreak\n\t\tif target is not None:\n\t\t\tcities = [c for c in cities if c.get('props', {}).get('region_id') == target or c.get('props', {}).get('region_id') == str(target)]\n\treturn jsonify({'cities': [{'id': c.get('id'), 'name_en': c.get('name_en'), 'name_ar': c.get('name_ar')} for c in cities]})\n@app.route('/list_districts')\ndef list_districts():",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ttarget",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\ttarget = r.get('id')\n\t\t\t\tbreak\n\t\tif target is not None:\n\t\t\tcities = [c for c in cities if c.get('props', {}).get('region_id') == target or c.get('props', {}).get('region_id') == str(target)]\n\treturn jsonify({'cities': [{'id': c.get('id'), 'name_en': c.get('name_en'), 'name_ar': c.get('name_ar')} for c in cities]})\n@app.route('/list_districts')\ndef list_districts():\n\t# Accept city_id or city_name\n\tcity_id = request.args.get('city_id')\n\tcity_name = request.args.get('city_name')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tcities",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tcities = [c for c in cities if c.get('props', {}).get('region_id') == target or c.get('props', {}).get('region_id') == str(target)]\n\treturn jsonify({'cities': [{'id': c.get('id'), 'name_en': c.get('name_en'), 'name_ar': c.get('name_ar')} for c in cities]})\n@app.route('/list_districts')\ndef list_districts():\n\t# Accept city_id or city_name\n\tcity_id = request.args.get('city_id')\n\tcity_name = request.args.get('city_name')\n\tdistricts = []\n\tif 'json_districts' in ALLOWED_FILES:\n\t\tdistricts = _load_list_from_key('json_districts', id_field_candidates=('district_id','id'), name_field_candidates=('name_en','name_ar'))",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tcity_id",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tcity_id = request.args.get('city_id')\n\tcity_name = request.args.get('city_name')\n\tdistricts = []\n\tif 'json_districts' in ALLOWED_FILES:\n\t\tdistricts = _load_list_from_key('json_districts', id_field_candidates=('district_id','id'), name_field_candidates=('name_en','name_ar'))\n\telif 'geo_districts' in ALLOWED_FILES:\n\t\tdistricts = _load_list_from_key('geo_districts', id_field_candidates=('district_id','id'), name_field_candidates=('name_en','name_ar'))\n\tif city_id:\n\t\ttry:\n\t\t\tcid = int(city_id)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tcity_name",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tcity_name = request.args.get('city_name')\n\tdistricts = []\n\tif 'json_districts' in ALLOWED_FILES:\n\t\tdistricts = _load_list_from_key('json_districts', id_field_candidates=('district_id','id'), name_field_candidates=('name_en','name_ar'))\n\telif 'geo_districts' in ALLOWED_FILES:\n\t\tdistricts = _load_list_from_key('geo_districts', id_field_candidates=('district_id','id'), name_field_candidates=('name_en','name_ar'))\n\tif city_id:\n\t\ttry:\n\t\t\tcid = int(city_id)\n\t\t\tdistricts = [d for d in districts if d.get('props', {}).get('city_id') == cid or d.get('props', {}).get('city_id') == str(cid)]",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tdistricts",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tdistricts = []\n\tif 'json_districts' in ALLOWED_FILES:\n\t\tdistricts = _load_list_from_key('json_districts', id_field_candidates=('district_id','id'), name_field_candidates=('name_en','name_ar'))\n\telif 'geo_districts' in ALLOWED_FILES:\n\t\tdistricts = _load_list_from_key('geo_districts', id_field_candidates=('district_id','id'), name_field_candidates=('name_en','name_ar'))\n\tif city_id:\n\t\ttry:\n\t\t\tcid = int(city_id)\n\t\t\tdistricts = [d for d in districts if d.get('props', {}).get('city_id') == cid or d.get('props', {}).get('city_id') == str(cid)]\n\t\texcept Exception:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tdistricts",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tdistricts = _load_list_from_key('json_districts', id_field_candidates=('district_id','id'), name_field_candidates=('name_en','name_ar'))\n\telif 'geo_districts' in ALLOWED_FILES:\n\t\tdistricts = _load_list_from_key('geo_districts', id_field_candidates=('district_id','id'), name_field_candidates=('name_en','name_ar'))\n\tif city_id:\n\t\ttry:\n\t\t\tcid = int(city_id)\n\t\t\tdistricts = [d for d in districts if d.get('props', {}).get('city_id') == cid or d.get('props', {}).get('city_id') == str(cid)]\n\t\texcept Exception:\n\t\t\tpass\n\telif city_name:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tdistricts",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tdistricts = _load_list_from_key('geo_districts', id_field_candidates=('district_id','id'), name_field_candidates=('name_en','name_ar'))\n\tif city_id:\n\t\ttry:\n\t\t\tcid = int(city_id)\n\t\t\tdistricts = [d for d in districts if d.get('props', {}).get('city_id') == cid or d.get('props', {}).get('city_id') == str(cid)]\n\t\texcept Exception:\n\t\t\tpass\n\telif city_name:\n\t\t# find city id by name\n\t\tcities = _load_list_from_key('json_cities') if 'json_cities' in ALLOWED_FILES else _load_list_from_key('geo_cities')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tcid",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tcid = int(city_id)\n\t\t\tdistricts = [d for d in districts if d.get('props', {}).get('city_id') == cid or d.get('props', {}).get('city_id') == str(cid)]\n\t\texcept Exception:\n\t\t\tpass\n\telif city_name:\n\t\t# find city id by name\n\t\tcities = _load_list_from_key('json_cities') if 'json_cities' in ALLOWED_FILES else _load_list_from_key('geo_cities')\n\t\tneedle = (city_name or '').strip().lower()\n\t\ttarget = None\n\t\tfor c in cities:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tdistricts",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tdistricts = [d for d in districts if d.get('props', {}).get('city_id') == cid or d.get('props', {}).get('city_id') == str(cid)]\n\t\texcept Exception:\n\t\t\tpass\n\telif city_name:\n\t\t# find city id by name\n\t\tcities = _load_list_from_key('json_cities') if 'json_cities' in ALLOWED_FILES else _load_list_from_key('geo_cities')\n\t\tneedle = (city_name or '').strip().lower()\n\t\ttarget = None\n\t\tfor c in cities:\n\t\t\tif c.get('name_en') and str(c.get('name_en')).strip().lower() == needle:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tcities",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tcities = _load_list_from_key('json_cities') if 'json_cities' in ALLOWED_FILES else _load_list_from_key('geo_cities')\n\t\tneedle = (city_name or '').strip().lower()\n\t\ttarget = None\n\t\tfor c in cities:\n\t\t\tif c.get('name_en') and str(c.get('name_en')).strip().lower() == needle:\n\t\t\t\ttarget = c.get('id')\n\t\t\t\tbreak\n\t\t\tif c.get('name_ar') and str(c.get('name_ar')).strip().lower() == needle:\n\t\t\t\ttarget = c.get('id')\n\t\t\t\tbreak",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tneedle",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tneedle = (city_name or '').strip().lower()\n\t\ttarget = None\n\t\tfor c in cities:\n\t\t\tif c.get('name_en') and str(c.get('name_en')).strip().lower() == needle:\n\t\t\t\ttarget = c.get('id')\n\t\t\t\tbreak\n\t\t\tif c.get('name_ar') and str(c.get('name_ar')).strip().lower() == needle:\n\t\t\t\ttarget = c.get('id')\n\t\t\t\tbreak\n\t\tif target is not None:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\ttarget",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\ttarget = None\n\t\tfor c in cities:\n\t\t\tif c.get('name_en') and str(c.get('name_en')).strip().lower() == needle:\n\t\t\t\ttarget = c.get('id')\n\t\t\t\tbreak\n\t\t\tif c.get('name_ar') and str(c.get('name_ar')).strip().lower() == needle:\n\t\t\t\ttarget = c.get('id')\n\t\t\t\tbreak\n\t\tif target is not None:\n\t\t\tdistricts = [d for d in districts if d.get('props', {}).get('city_id') == target or d.get('props', {}).get('city_id') == str(target)]",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ttarget",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\ttarget = c.get('id')\n\t\t\t\tbreak\n\t\t\tif c.get('name_ar') and str(c.get('name_ar')).strip().lower() == needle:\n\t\t\t\ttarget = c.get('id')\n\t\t\t\tbreak\n\t\tif target is not None:\n\t\t\tdistricts = [d for d in districts if d.get('props', {}).get('city_id') == target or d.get('props', {}).get('city_id') == str(target)]\n\treturn jsonify({'districts': [{'id': d.get('id'), 'name_en': d.get('name_en'), 'name_ar': d.get('name_ar')} for d in districts]})\n@app.route('/stats_file_feature')\ndef stats_file_feature():",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\t\ttarget",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\t\ttarget = c.get('id')\n\t\t\t\tbreak\n\t\tif target is not None:\n\t\t\tdistricts = [d for d in districts if d.get('props', {}).get('city_id') == target or d.get('props', {}).get('city_id') == str(target)]\n\treturn jsonify({'districts': [{'id': d.get('id'), 'name_en': d.get('name_en'), 'name_ar': d.get('name_ar')} for d in districts]})\n@app.route('/stats_file_feature')\ndef stats_file_feature():\n\t\"\"\"Return a matched feature from one of the allowed external files.\n\tQuery params:\n\t- file: key of ALLOWED_FILES (required)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tdistricts",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tdistricts = [d for d in districts if d.get('props', {}).get('city_id') == target or d.get('props', {}).get('city_id') == str(target)]\n\treturn jsonify({'districts': [{'id': d.get('id'), 'name_en': d.get('name_en'), 'name_ar': d.get('name_ar')} for d in districts]})\n@app.route('/stats_file_feature')\ndef stats_file_feature():\n\t\"\"\"Return a matched feature from one of the allowed external files.\n\tQuery params:\n\t- file: key of ALLOWED_FILES (required)\n\t- neighborhood: name to search (required)\n\t- name_field (optional): comma-separated list of property names to try\n\t\"\"\"",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tfile_key",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tfile_key = request.args.get('file')\n\tneighborhood = request.args.get('neighborhood')\n\tif not file_key or file_key not in ALLOWED_FILES:\n\t\treturn jsonify({'error': 'invalid or missing file parameter'}), 400\n\tif not neighborhood:\n\t\treturn jsonify({'error': 'missing neighborhood parameter'}), 400\n\tname_field_param = request.args.get('name_field')\n\tcandidates = None\n\tif name_field_param:\n\t\tcandidates = [s.strip() for s in name_field_param.split(',') if s.strip()]",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tneighborhood",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tneighborhood = request.args.get('neighborhood')\n\tif not file_key or file_key not in ALLOWED_FILES:\n\t\treturn jsonify({'error': 'invalid or missing file parameter'}), 400\n\tif not neighborhood:\n\t\treturn jsonify({'error': 'missing neighborhood parameter'}), 400\n\tname_field_param = request.args.get('name_field')\n\tcandidates = None\n\tif name_field_param:\n\t\tcandidates = [s.strip() for s in name_field_param.split(',') if s.strip()]\n\tfeat = query_file_feature(file_key, neighborhood, candidates)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tname_field_param",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tname_field_param = request.args.get('name_field')\n\tcandidates = None\n\tif name_field_param:\n\t\tcandidates = [s.strip() for s in name_field_param.split(',') if s.strip()]\n\tfeat = query_file_feature(file_key, neighborhood, candidates)\n\tif not feat:\n\t\treturn jsonify({'error': 'feature not found'}), 404\n\tprops = feat.get('properties', {})\n\t# attach any local population mapping if exists (match by neighborhood key)\n\tregion_name = props.get('name') or props.get('NAME') or props.get('EN_NAME')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tcandidates",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tcandidates = None\n\tif name_field_param:\n\t\tcandidates = [s.strip() for s in name_field_param.split(',') if s.strip()]\n\tfeat = query_file_feature(file_key, neighborhood, candidates)\n\tif not feat:\n\t\treturn jsonify({'error': 'feature not found'}), 404\n\tprops = feat.get('properties', {})\n\t# attach any local population mapping if exists (match by neighborhood key)\n\tregion_name = props.get('name') or props.get('NAME') or props.get('EN_NAME')\n\tpop = load_region_populations()",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tcandidates",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tcandidates = [s.strip() for s in name_field_param.split(',') if s.strip()]\n\tfeat = query_file_feature(file_key, neighborhood, candidates)\n\tif not feat:\n\t\treturn jsonify({'error': 'feature not found'}), 404\n\tprops = feat.get('properties', {})\n\t# attach any local population mapping if exists (match by neighborhood key)\n\tregion_name = props.get('name') or props.get('NAME') or props.get('EN_NAME')\n\tpop = load_region_populations()\n\tpop_entry = None\n\tif region_name:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tfeat",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tfeat = query_file_feature(file_key, neighborhood, candidates)\n\tif not feat:\n\t\treturn jsonify({'error': 'feature not found'}), 404\n\tprops = feat.get('properties', {})\n\t# attach any local population mapping if exists (match by neighborhood key)\n\tregion_name = props.get('name') or props.get('NAME') or props.get('EN_NAME')\n\tpop = load_region_populations()\n\tpop_entry = None\n\tif region_name:\n\t\tpop_entry = pop.get(region_name) or pop.get(region_name.strip().lower()) or pop.get(region_name.strip().upper())",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tprops",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tprops = feat.get('properties', {})\n\t# attach any local population mapping if exists (match by neighborhood key)\n\tregion_name = props.get('name') or props.get('NAME') or props.get('EN_NAME')\n\tpop = load_region_populations()\n\tpop_entry = None\n\tif region_name:\n\t\tpop_entry = pop.get(region_name) or pop.get(region_name.strip().lower()) or pop.get(region_name.strip().upper())\n\tresponse = {'neighborhood': region_name or neighborhood, 'feature': feat, 'properties': props}\n\tif pop_entry:\n\t\ttry:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tregion_name",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tregion_name = props.get('name') or props.get('NAME') or props.get('EN_NAME')\n\tpop = load_region_populations()\n\tpop_entry = None\n\tif region_name:\n\t\tpop_entry = pop.get(region_name) or pop.get(region_name.strip().lower()) or pop.get(region_name.strip().upper())\n\tresponse = {'neighborhood': region_name or neighborhood, 'feature': feat, 'properties': props}\n\tif pop_entry:\n\t\ttry:\n\t\t\tmale = float(pop_entry.get('POP_M', 0))\n\t\texcept Exception:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tpop",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tpop = load_region_populations()\n\tpop_entry = None\n\tif region_name:\n\t\tpop_entry = pop.get(region_name) or pop.get(region_name.strip().lower()) or pop.get(region_name.strip().upper())\n\tresponse = {'neighborhood': region_name or neighborhood, 'feature': feat, 'properties': props}\n\tif pop_entry:\n\t\ttry:\n\t\t\tmale = float(pop_entry.get('POP_M', 0))\n\t\texcept Exception:\n\t\t\tmale = 0",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tpop_entry",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tpop_entry = None\n\tif region_name:\n\t\tpop_entry = pop.get(region_name) or pop.get(region_name.strip().lower()) or pop.get(region_name.strip().upper())\n\tresponse = {'neighborhood': region_name or neighborhood, 'feature': feat, 'properties': props}\n\tif pop_entry:\n\t\ttry:\n\t\t\tmale = float(pop_entry.get('POP_M', 0))\n\t\texcept Exception:\n\t\t\tmale = 0\n\t\ttry:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tpop_entry",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tpop_entry = pop.get(region_name) or pop.get(region_name.strip().lower()) or pop.get(region_name.strip().upper())\n\tresponse = {'neighborhood': region_name or neighborhood, 'feature': feat, 'properties': props}\n\tif pop_entry:\n\t\ttry:\n\t\t\tmale = float(pop_entry.get('POP_M', 0))\n\t\texcept Exception:\n\t\t\tmale = 0\n\t\ttry:\n\t\t\tfemale = float(pop_entry.get('POP_F', 0))\n\t\texcept Exception:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tresponse",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tresponse = {'neighborhood': region_name or neighborhood, 'feature': feat, 'properties': props}\n\tif pop_entry:\n\t\ttry:\n\t\t\tmale = float(pop_entry.get('POP_M', 0))\n\t\texcept Exception:\n\t\t\tmale = 0\n\t\ttry:\n\t\t\tfemale = float(pop_entry.get('POP_F', 0))\n\t\texcept Exception:\n\t\t\tfemale = 0",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tmale",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tmale = float(pop_entry.get('POP_M', 0))\n\t\texcept Exception:\n\t\t\tmale = 0\n\t\ttry:\n\t\t\tfemale = float(pop_entry.get('POP_F', 0))\n\t\texcept Exception:\n\t\t\tfemale = 0\n\t\tresponse.update({'population_male': male, 'population_female': female, 'population_total': male + female})\n\treturn jsonify(response)\n# Note: `/stats_region_feature` and the SA_regions.json loader were removed.",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tmale",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tmale = 0\n\t\ttry:\n\t\t\tfemale = float(pop_entry.get('POP_F', 0))\n\t\texcept Exception:\n\t\t\tfemale = 0\n\t\tresponse.update({'population_male': male, 'population_female': female, 'population_total': male + female})\n\treturn jsonify(response)\n# Note: `/stats_region_feature` and the SA_regions.json loader were removed.\ndef query_layer_sum(layer_url, neighborhood_field, neighborhood_value, population_field):\n\t\"\"\"Query the ArcGIS FeatureLayer for features matching a neighborhood and sum the population field.\"\"\"",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tfemale",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tfemale = float(pop_entry.get('POP_F', 0))\n\t\texcept Exception:\n\t\t\tfemale = 0\n\t\tresponse.update({'population_male': male, 'population_female': female, 'population_total': male + female})\n\treturn jsonify(response)\n# Note: `/stats_region_feature` and the SA_regions.json loader were removed.\ndef query_layer_sum(layer_url, neighborhood_field, neighborhood_value, population_field):\n\t\"\"\"Query the ArcGIS FeatureLayer for features matching a neighborhood and sum the population field.\"\"\"\n\t# Build a safe where clause; ArcGIS expects single quotes around string values\n\twhere = f\"{neighborhood_field} = '{neighborhood_value.replace(\"'\",\"''\")}'\"",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\t\tfemale",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\t\tfemale = 0\n\t\tresponse.update({'population_male': male, 'population_female': female, 'population_total': male + female})\n\treturn jsonify(response)\n# Note: `/stats_region_feature` and the SA_regions.json loader were removed.\ndef query_layer_sum(layer_url, neighborhood_field, neighborhood_value, population_field):\n\t\"\"\"Query the ArcGIS FeatureLayer for features matching a neighborhood and sum the population field.\"\"\"\n\t# Build a safe where clause; ArcGIS expects single quotes around string values\n\twhere = f\"{neighborhood_field} = '{neighborhood_value.replace(\"'\",\"''\")}'\"\n\tparams = {\n\t\t'where': where,",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\twhere",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\twhere = f\"{neighborhood_field} = '{neighborhood_value.replace(\"'\",\"''\")}'\"\n\tparams = {\n\t\t'where': where,\n\t\t'outFields': population_field,\n\t\t'returnGeometry': 'false',\n\t\t'f': 'json'\n\t}\n\tresp = requests.get(f\"{layer_url.rstrip('/')}/query\", params=params, timeout=30)\n\tresp.raise_for_status()\n\tdata = resp.json()",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tparams",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tparams = {\n\t\t'where': where,\n\t\t'outFields': population_field,\n\t\t'returnGeometry': 'false',\n\t\t'f': 'json'\n\t}\n\tresp = requests.get(f\"{layer_url.rstrip('/')}/query\", params=params, timeout=30)\n\tresp.raise_for_status()\n\tdata = resp.json()\n\tfeatures = data.get('features', [])",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tresp",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tresp = requests.get(f\"{layer_url.rstrip('/')}/query\", params=params, timeout=30)\n\tresp.raise_for_status()\n\tdata = resp.json()\n\tfeatures = data.get('features', [])\n\ttotal_pop = 0\n\tcount = 0\n\tfor feat in features:\n\t\tattrs = feat.get('attributes', {})\n\t\tval = attrs.get(population_field)\n\t\ttry:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tdata",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tdata = resp.json()\n\tfeatures = data.get('features', [])\n\ttotal_pop = 0\n\tcount = 0\n\tfor feat in features:\n\t\tattrs = feat.get('attributes', {})\n\t\tval = attrs.get(population_field)\n\t\ttry:\n\t\t\tif val is None:\n\t\t\t\tcontinue",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tfeatures",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tfeatures = data.get('features', [])\n\ttotal_pop = 0\n\tcount = 0\n\tfor feat in features:\n\t\tattrs = feat.get('attributes', {})\n\t\tval = attrs.get(population_field)\n\t\ttry:\n\t\t\tif val is None:\n\t\t\t\tcontinue\n\t\t\ttotal_pop += float(val)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\ttotal_pop",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\ttotal_pop = 0\n\tcount = 0\n\tfor feat in features:\n\t\tattrs = feat.get('attributes', {})\n\t\tval = attrs.get(population_field)\n\t\ttry:\n\t\t\tif val is None:\n\t\t\t\tcontinue\n\t\t\ttotal_pop += float(val)\n\t\t\tcount += 1",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tcount",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tcount = 0\n\tfor feat in features:\n\t\tattrs = feat.get('attributes', {})\n\t\tval = attrs.get(population_field)\n\t\ttry:\n\t\t\tif val is None:\n\t\t\t\tcontinue\n\t\t\ttotal_pop += float(val)\n\t\t\tcount += 1\n\t\texcept Exception:",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tattrs",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tattrs = feat.get('attributes', {})\n\t\tval = attrs.get(population_field)\n\t\ttry:\n\t\t\tif val is None:\n\t\t\t\tcontinue\n\t\t\ttotal_pop += float(val)\n\t\t\tcount += 1\n\t\texcept Exception:\n\t\t\tcontinue\n\treturn {",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tval",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tval = attrs.get(population_field)\n\t\ttry:\n\t\t\tif val is None:\n\t\t\t\tcontinue\n\t\t\ttotal_pop += float(val)\n\t\t\tcount += 1\n\t\texcept Exception:\n\t\t\tcontinue\n\treturn {\n\t\t'neighborhood': neighborhood_value,",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tout_statistics",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tout_statistics = json.dumps([\n\t\t{\"statisticType\": \"sum\", \"onStatisticField\": population_field, \"outStatisticFieldName\": \"SUM_POP\"}\n\t])\n\tparams = {\n\t\t'where': where_clause,\n\t\t'f': 'json',\n\t\t'groupByFieldsForStatistics': neighborhood_field,\n\t\t'outStatistics': out_statistics,\n\t\t'returnGeometry': 'false'\n\t}",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tparams",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tparams = {\n\t\t'where': where_clause,\n\t\t'f': 'json',\n\t\t'groupByFieldsForStatistics': neighborhood_field,\n\t\t'outStatistics': out_statistics,\n\t\t'returnGeometry': 'false'\n\t}\n\tresp = requests.get(f\"{layer_url.rstrip('/')}/query\", params=params, timeout=30)\n\tresp.raise_for_status()\n\tdata = resp.json()",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tresp",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tresp = requests.get(f\"{layer_url.rstrip('/')}/query\", params=params, timeout=30)\n\tresp.raise_for_status()\n\tdata = resp.json()\n\tstats = []\n\tfor feat in data.get('features', []):\n\t\tattrs = feat.get('attributes', {})\n\t\tstats.append({\n\t\t\t'neighborhood': attrs.get(neighborhood_field),\n\t\t\t'population_sum': attrs.get('SUM_POP')\n\t\t})",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tdata",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tdata = resp.json()\n\tstats = []\n\tfor feat in data.get('features', []):\n\t\tattrs = feat.get('attributes', {})\n\t\tstats.append({\n\t\t\t'neighborhood': attrs.get(neighborhood_field),\n\t\t\t'population_sum': attrs.get('SUM_POP')\n\t\t})\n\treturn stats\n@app.route('/')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tstats",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tstats = []\n\tfor feat in data.get('features', []):\n\t\tattrs = feat.get('attributes', {})\n\t\tstats.append({\n\t\t\t'neighborhood': attrs.get(neighborhood_field),\n\t\t\t'population_sum': attrs.get('SUM_POP')\n\t\t})\n\treturn stats\n@app.route('/')\ndef index():",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tattrs",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tattrs = feat.get('attributes', {})\n\t\tstats.append({\n\t\t\t'neighborhood': attrs.get(neighborhood_field),\n\t\t\t'population_sum': attrs.get('SUM_POP')\n\t\t})\n\treturn stats\n@app.route('/')\ndef index():\n\t# Render a simple page that loads ESRI map and calls this API for stats\n\treturn render_template('map.html')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tneighborhood",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tneighborhood = request.args.get('neighborhood')\n\tif not neighborhood:\n\t\treturn jsonify({'error': 'missing neighborhood parameter'}), 400\n\tlayer_url = request.args.get('layer_url', DEFAULT_LAYER_URL)\n\tneighborhood_field = request.args.get('neighborhood_field', DEFAULT_NEIGHBOR_FIELD)\n\tpopulation_field = request.args.get('population_field', DEFAULT_POP_FIELD)\n\ttry:\n\t\tresult = query_layer_sum(layer_url, neighborhood_field, neighborhood, population_field)\n\texcept requests.HTTPError as e:\n\t\treturn jsonify({'error': 'failed to query layer', 'details': str(e)}), 500",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tlayer_url",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tlayer_url = request.args.get('layer_url', DEFAULT_LAYER_URL)\n\tneighborhood_field = request.args.get('neighborhood_field', DEFAULT_NEIGHBOR_FIELD)\n\tpopulation_field = request.args.get('population_field', DEFAULT_POP_FIELD)\n\ttry:\n\t\tresult = query_layer_sum(layer_url, neighborhood_field, neighborhood, population_field)\n\texcept requests.HTTPError as e:\n\t\treturn jsonify({'error': 'failed to query layer', 'details': str(e)}), 500\n\texcept Exception as e:\n\t\treturn jsonify({'error': 'unexpected error', 'details': str(e)}), 500\n\treturn jsonify(result)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tneighborhood_field",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tneighborhood_field = request.args.get('neighborhood_field', DEFAULT_NEIGHBOR_FIELD)\n\tpopulation_field = request.args.get('population_field', DEFAULT_POP_FIELD)\n\ttry:\n\t\tresult = query_layer_sum(layer_url, neighborhood_field, neighborhood, population_field)\n\texcept requests.HTTPError as e:\n\t\treturn jsonify({'error': 'failed to query layer', 'details': str(e)}), 500\n\texcept Exception as e:\n\t\treturn jsonify({'error': 'unexpected error', 'details': str(e)}), 500\n\treturn jsonify(result)\n@app.route('/stats_all')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tpopulation_field",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tpopulation_field = request.args.get('population_field', DEFAULT_POP_FIELD)\n\ttry:\n\t\tresult = query_layer_sum(layer_url, neighborhood_field, neighborhood, population_field)\n\texcept requests.HTTPError as e:\n\t\treturn jsonify({'error': 'failed to query layer', 'details': str(e)}), 500\n\texcept Exception as e:\n\t\treturn jsonify({'error': 'unexpected error', 'details': str(e)}), 500\n\treturn jsonify(result)\n@app.route('/stats_all')\ndef stats_all():",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tresult",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tresult = query_layer_sum(layer_url, neighborhood_field, neighborhood, population_field)\n\texcept requests.HTTPError as e:\n\t\treturn jsonify({'error': 'failed to query layer', 'details': str(e)}), 500\n\texcept Exception as e:\n\t\treturn jsonify({'error': 'unexpected error', 'details': str(e)}), 500\n\treturn jsonify(result)\n@app.route('/stats_all')\ndef stats_all():\n\t\"\"\"Return grouped population sums for all neighborhoods.\n\tQuery params (optional): layer_url, neighborhood_field, population_field",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tlayer_url",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tlayer_url = request.args.get('layer_url', DEFAULT_LAYER_URL)\n\tneighborhood_field = request.args.get('neighborhood_field', DEFAULT_NEIGHBOR_FIELD)\n\tpopulation_field = request.args.get('population_field', DEFAULT_POP_FIELD)\n\twhere_clause = request.args.get('where', '1=1')\n\ttry:\n\t\tstats = query_layer_group_sum(layer_url, neighborhood_field, population_field, where_clause)\n\texcept requests.HTTPError as e:\n\t\treturn jsonify({'error': 'failed to query layer', 'details': str(e)}), 500\n\texcept Exception as e:\n\t\treturn jsonify({'error': 'unexpected error', 'details': str(e)}), 500",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tneighborhood_field",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tneighborhood_field = request.args.get('neighborhood_field', DEFAULT_NEIGHBOR_FIELD)\n\tpopulation_field = request.args.get('population_field', DEFAULT_POP_FIELD)\n\twhere_clause = request.args.get('where', '1=1')\n\ttry:\n\t\tstats = query_layer_group_sum(layer_url, neighborhood_field, population_field, where_clause)\n\texcept requests.HTTPError as e:\n\t\treturn jsonify({'error': 'failed to query layer', 'details': str(e)}), 500\n\texcept Exception as e:\n\t\treturn jsonify({'error': 'unexpected error', 'details': str(e)}), 500\n\t# Optionally sort descending by population",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tpopulation_field",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tpopulation_field = request.args.get('population_field', DEFAULT_POP_FIELD)\n\twhere_clause = request.args.get('where', '1=1')\n\ttry:\n\t\tstats = query_layer_group_sum(layer_url, neighborhood_field, population_field, where_clause)\n\texcept requests.HTTPError as e:\n\t\treturn jsonify({'error': 'failed to query layer', 'details': str(e)}), 500\n\texcept Exception as e:\n\t\treturn jsonify({'error': 'unexpected error', 'details': str(e)}), 500\n\t# Optionally sort descending by population\n\tstats_sorted = sorted(stats, key=lambda x: (x['population_sum'] or 0), reverse=True)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\twhere_clause",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\twhere_clause = request.args.get('where', '1=1')\n\ttry:\n\t\tstats = query_layer_group_sum(layer_url, neighborhood_field, population_field, where_clause)\n\texcept requests.HTTPError as e:\n\t\treturn jsonify({'error': 'failed to query layer', 'details': str(e)}), 500\n\texcept Exception as e:\n\t\treturn jsonify({'error': 'unexpected error', 'details': str(e)}), 500\n\t# Optionally sort descending by population\n\tstats_sorted = sorted(stats, key=lambda x: (x['population_sum'] or 0), reverse=True)\n\treturn jsonify({'stats': stats_sorted})",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\t\tstats",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\t\tstats = query_layer_group_sum(layer_url, neighborhood_field, population_field, where_clause)\n\texcept requests.HTTPError as e:\n\t\treturn jsonify({'error': 'failed to query layer', 'details': str(e)}), 500\n\texcept Exception as e:\n\t\treturn jsonify({'error': 'unexpected error', 'details': str(e)}), 500\n\t# Optionally sort descending by population\n\tstats_sorted = sorted(stats, key=lambda x: (x['population_sum'] or 0), reverse=True)\n\treturn jsonify({'stats': stats_sorted})\n@app.route('/stats_sample')\ndef stats_sample():",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tstats_sorted",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tstats_sorted = sorted(stats, key=lambda x: (x['population_sum'] or 0), reverse=True)\n\treturn jsonify({'stats': stats_sorted})\n@app.route('/stats_sample')\ndef stats_sample():\n\t\"\"\"Return population statistics using the local sample GeoJSON file.\n\tQuery params:\n\t- neighborhood (required)\n\t- neighborhood_field (optional) defaults to NAME\n\t- population_field (optional) defaults to POP\n\t\"\"\"",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tneighborhood",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tneighborhood = request.args.get('neighborhood')\n\tif not neighborhood:\n\t\treturn jsonify({'error': 'missing neighborhood parameter'}), 400\n\tneighborhood_field = request.args.get('neighborhood_field', 'NAME')\n\tpopulation_field = request.args.get('population_field', 'POP')\n\tresult = query_sample_sum(neighborhood_field, neighborhood, population_field)\n\treturn jsonify(result)\n@app.route('/stats_all_sample')\ndef stats_all_sample():\n\t\"\"\"Return grouped population sums for the sample GeoJSON.\"\"\"",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tneighborhood_field",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tneighborhood_field = request.args.get('neighborhood_field', 'NAME')\n\tpopulation_field = request.args.get('population_field', 'POP')\n\tresult = query_sample_sum(neighborhood_field, neighborhood, population_field)\n\treturn jsonify(result)\n@app.route('/stats_all_sample')\ndef stats_all_sample():\n\t\"\"\"Return grouped population sums for the sample GeoJSON.\"\"\"\n\tneighborhood_field = request.args.get('neighborhood_field', 'NAME')\n\tpopulation_field = request.args.get('population_field', 'POP')\n\tstats = query_sample_group_sum(neighborhood_field, population_field)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tpopulation_field",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tpopulation_field = request.args.get('population_field', 'POP')\n\tresult = query_sample_sum(neighborhood_field, neighborhood, population_field)\n\treturn jsonify(result)\n@app.route('/stats_all_sample')\ndef stats_all_sample():\n\t\"\"\"Return grouped population sums for the sample GeoJSON.\"\"\"\n\tneighborhood_field = request.args.get('neighborhood_field', 'NAME')\n\tpopulation_field = request.args.get('population_field', 'POP')\n\tstats = query_sample_group_sum(neighborhood_field, population_field)\n\treturn jsonify({'stats': stats})",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tresult",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tresult = query_sample_sum(neighborhood_field, neighborhood, population_field)\n\treturn jsonify(result)\n@app.route('/stats_all_sample')\ndef stats_all_sample():\n\t\"\"\"Return grouped population sums for the sample GeoJSON.\"\"\"\n\tneighborhood_field = request.args.get('neighborhood_field', 'NAME')\n\tpopulation_field = request.args.get('population_field', 'POP')\n\tstats = query_sample_group_sum(neighborhood_field, population_field)\n\treturn jsonify({'stats': stats})\n@app.route('/stats_sample_feature')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tneighborhood_field",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tneighborhood_field = request.args.get('neighborhood_field', 'NAME')\n\tpopulation_field = request.args.get('population_field', 'POP')\n\tstats = query_sample_group_sum(neighborhood_field, population_field)\n\treturn jsonify({'stats': stats})\n@app.route('/stats_sample_feature')\ndef stats_sample_feature():\n\t\"\"\"Return a single matching feature with geometry and gender breakdown for the sample GeoJSON.\n\tQuery params:\n\t- neighborhood (required)\n\t- neighborhood_field (optional)",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tpopulation_field",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tpopulation_field = request.args.get('population_field', 'POP')\n\tstats = query_sample_group_sum(neighborhood_field, population_field)\n\treturn jsonify({'stats': stats})\n@app.route('/stats_sample_feature')\ndef stats_sample_feature():\n\t\"\"\"Return a single matching feature with geometry and gender breakdown for the sample GeoJSON.\n\tQuery params:\n\t- neighborhood (required)\n\t- neighborhood_field (optional)\n\t\"\"\"",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tstats",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tstats = query_sample_group_sum(neighborhood_field, population_field)\n\treturn jsonify({'stats': stats})\n@app.route('/stats_sample_feature')\ndef stats_sample_feature():\n\t\"\"\"Return a single matching feature with geometry and gender breakdown for the sample GeoJSON.\n\tQuery params:\n\t- neighborhood (required)\n\t- neighborhood_field (optional)\n\t\"\"\"\n\tneighborhood = request.args.get('neighborhood')",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tneighborhood",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tneighborhood = request.args.get('neighborhood')\n\tif not neighborhood:\n\t\treturn jsonify({'error': 'missing neighborhood parameter'}), 400\n\tneighborhood_field = request.args.get('neighborhood_field', 'NAME')\n\tresult = query_sample_feature(neighborhood_field, neighborhood)\n\tif not result:\n\t\treturn jsonify({'error': 'neighborhood not found'}), 404\n\t# return the feature (as GeoJSON) and counts\n\treturn jsonify({\n\t\t'neighborhood': result['neighborhood'],",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tneighborhood_field",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tneighborhood_field = request.args.get('neighborhood_field', 'NAME')\n\tresult = query_sample_feature(neighborhood_field, neighborhood)\n\tif not result:\n\t\treturn jsonify({'error': 'neighborhood not found'}), 404\n\t# return the feature (as GeoJSON) and counts\n\treturn jsonify({\n\t\t'neighborhood': result['neighborhood'],\n\t\t'population_male': result['population_male'],\n\t\t'population_female': result['population_female'],\n\t\t'population_total': result['population_total'],",
        "detail": "map",
        "documentation": {}
    },
    {
        "label": "\tresult",
        "kind": 5,
        "importPath": "map",
        "description": "map",
        "peekOfCode": "\tresult = query_sample_feature(neighborhood_field, neighborhood)\n\tif not result:\n\t\treturn jsonify({'error': 'neighborhood not found'}), 404\n\t# return the feature (as GeoJSON) and counts\n\treturn jsonify({\n\t\t'neighborhood': result['neighborhood'],\n\t\t'population_male': result['population_male'],\n\t\t'population_female': result['population_female'],\n\t\t'population_total': result['population_total'],\n\t\t'feature': result['feature']",
        "detail": "map",
        "documentation": {}
    }
]